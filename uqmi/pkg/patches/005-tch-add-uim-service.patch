--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -20,7 +20,7 @@ ENDIF()

 SET(service_headers)
 SET(service_sources)
-FOREACH(service ctl dms nas pds wds wms wda)
+FOREACH(service ctl dms nas pds wds wms wda uim)
 	ADD_CUSTOM_COMMAND(
 		OUTPUT qmi-message-${service}.h
 		COMMAND ./data/gen-header.pl ${service}_ ./data/qmi-service-${service}.json > qmi-message-${service}.h
--- a/commands.h
+++ b/commands.h
@@ -28,6 +28,7 @@
 #include "commands-nas.h"
 #include "commands-wms.h"
 #include "commands-wda.h"
+#include "commands-uim.h"

 enum qmi_cmd_result {
 	QMI_CMD_DONE,
@@ -61,7 +62,8 @@ struct uqmi_cmd {
 	__uqmi_dms_commands, \
 	__uqmi_nas_commands, \
 	__uqmi_wms_commands, \
-	__uqmi_wda_commands
+	__uqmi_wda_commands, \
+	__uqmi_uim_commands

 #define __uqmi_command(_name, _optname, _arg, _option) __UQMI_COMMAND_##_name
 enum uqmi_command {
--- a/commands.c
+++ b/commands.c
@@ -161,6 +161,7 @@ cmd_ctl_set_data_format_prepare(struct q
 #include "commands-nas.c"
 #include "commands-wms.c"
 #include "commands-wda.c"
+#include "commands-uim.c"

 #define __uqmi_command(_name, _optname, _arg, _type) \
 	[__UQMI_COMMAND_##_name] = { \
--- a/commands-uim.h
+++ b/commands-uim.h
@@ -0,0 +1,56 @@
+/*
+ * uqmi -- tiny QMI support implementation
+ *
+ * Copyright (C) 2014-2015 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ */
+
+#define __uqmi_uim_commands \
+	__uqmi_command(uim_get_card_status, uim-get-card-status, no, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_verify_pin1, uim-verify-pin1, required, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_verify_pin2, uim-verify-pin2, required, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_set_pin1_protect, uim-set-pin1-protection, required, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_set_pin2_protect, uim-set-pin2-protection, required, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_set_upin, upin, required, CMD_TYPE_OPTION), \
+	__uqmi_command(uim_change_pin1, uim-change-pin1, no, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_change_pin2, uim-change-pin2, no, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_set_unew_pin, unew-pin, required, CMD_TYPE_OPTION), \
+	__uqmi_command(uim_unblock_pin1, uim-unblock-pin1, required, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_unblock_pin2, uim-unblock-pin2, required, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_set_upuk, upuk, required, CMD_TYPE_OPTION) \
+
+#define uim_helptext \
+		"  --uim-get-card-status:            Get status of UIM card\n" \
+		"  --uim-verify-pin1 <pin>:          Verify PIN1\n" \
+		"  --uim-verify-pin2 <pin>:          Verify PIN2\n" \
+		"  --uim-set-pin1-protect <state>:   Set PIN1 protection state (disabled, enabled)\n" \
+		"    --upin <pin>:                    PIN1 needed to change state\n" \
+		"  --uim-set-pin2-protect <state>:   Set PIN2 protection state (disabled, enabled)\n" \
+		"    --upin <pin>:                    PIN2 needed to change state\n" \
+		"  --uim-change-pin1:                Change PIN1\n" \
+		"    --upin <old pin>:                Current PIN1\n" \
+		"    --unew-pin <new pin>:            New pin\n" \
+		"  --uim-change-pin2:                Change PIN2\n" \
+		"    --upin <old pin>:                Current PIN2\n" \
+		"    --unew-pin <new pin>:            New pin\n" \
+		"  --uim-unblock-pin1:               Unblock PIN1\n" \
+		"    --upuk <puk>:                    PUK needed to unblock\n" \
+		"    --upin <new pin>:                New pin\n" \
+		"  --uim-unblock-pin2:               Unblock PIN2\n" \
+		"    --upuk <puk>:                    PUK needed to unblock\n" \
+		"    --upin <new pin>:                New pin\n" \
+
--- a/commands-uim.c
+++ b/commands-uim.c
@@ -0,0 +1,507 @@
+/*
+ * uqmi -- tiny QMI support implementation
+ *
+ * Copyright (C) 2014-2015 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include "qmi-message.h"
+
+static struct {
+	QmiDmsUimPinId pin_id;
+	uint8_t        pin_len;
+	uint8_t *      pin_value;
+	uint8_t        new_pin_len;
+	uint8_t *      new_pin_value;
+	uint8_t        puk_len;
+	uint8_t *      puk_value;
+} uim_req_data;
+
+const char *card_state[] = {
+[QMI_UIM_CARD_STATE_ABSENT]  = "absent",
+[QMI_UIM_CARD_STATE_PRESENT] = "present",
+[QMI_UIM_CARD_STATE_ERROR]   = "error",
+};
+
+const char *pin_state[] = {
+[QMI_UIM_PIN_STATE_UNKNOWN]              = "unknown",
+[QMI_UIM_PIN_STATE_ENABLED_NOT_VERIFIED] = "enabled_not_verified",
+[QMI_UIM_PIN_STATE_ENABLED_VERIFIED]     = "enabled_verified",
+[QMI_UIM_PIN_STATE_DISABLED]             = "disabled",
+[QMI_UIM_PIN_STATE_BLOCKED]              = "blocked",
+[QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED]  = "permanently_blocked",
+};
+
+const char *error_code[] = {
+[QMI_UIM_ERROR_CODE_UNKNOWN]            = "unknown",
+[QMI_UIM_ERROR_CODE_POWER_DOWN]         = "power_down",
+[QMI_UIM_ERROR_CODE_POLL_ERROR]         = "poll_error",
+[QMI_UIM_ERROR_CODE_NO_ATR_RECEIVED]    = "no_ATR_received",
+[QMI_UIM_ERROR_CODE_VOLT_MISMATCH]      = "volt_mismatch",
+[QMI_UIM_ERROR_CODE_PARITY_ERROR]       = "parity_error",
+[QMI_UIM_ERROR_CODE_POSSIBLY_REMOVED]   = "possibly_removed",
+[QMI_UIM_ERROR_CODE_TECHNICAL_PROBLEMS] = "technical_problem",
+};
+
+const char *app_type[] = {
+[QMI_UIM_APP_TYPE_UNKNOWN]          = "unknown",
+[QMI_UIM_APP_TYPE_SIM_CARD]         = "SIM_card",
+[QMI_UIM_APP_TYPE_USIM_APPLICATION] = "USIM_application",
+[QMI_UIM_APP_TYPE_RUIM_CARD]        = "RUIM_card",
+[QMI_UIM_APP_TYPE_CSIM_APPLICATION] = "CSIM_application",
+[QMI_UIM_APP_TYPE_ISIM_APPLICATION] = "ISIM_application",
+};
+
+const char *app_state[] = {
+[QMI_UIM_APP_STATE_UNKNOWN]           = "unknown",
+[QMI_UIM_APP_STATE_DETECTED]          = "detected",
+[QMI_UIM_APP_STATE_PIN_REQUIRED]      = "PIN_required",
+[QMI_UIM_APP_STATE_PUK_REQUIRED]      = "PUK_required",
+[QMI_UIM_APP_STATE_CHECK_PERSO_STATE] = "check_perso_state",
+[QMI_UIM_APP_STATE_PIN1_BLOCKED]      = "PIN1_blocked",
+[QMI_UIM_APP_STATE_ILLEGAL]           = "illegal",
+[QMI_UIM_APP_STATE_READY]             = "ready",
+};
+
+const char *perso_state[] = {
+[QMI_UIM_PERSO_STATE_UNKNOWN]                     = "unknown",
+[QMI_UIM_PERSO_STATE_PERSO_OP_IN_PROGRESS]        = "perso_op_in_progress",
+[QMI_UIM_PERSO_STATE_READY]                       = "ready",
+[QMI_UIM_PERSO_STATE_PERSO_CODE_REQUIRED]         = "perso_code_required",
+[QMI_UIM_PERSO_STATE_PUK_FOR_PERSO_CODE_REQUIRED] = "PUK_for_perso_code_required",
+[QMI_UIM_PERSO_STATE_PERMANENTLY_BLOCKED]         = "permanently_blocked",
+};
+
+const char *perso_feature[] = {
+[QMI_UIM_PERSO_FEATURE_GW_NETW_PERSO]        = "GW_netw_perso",
+[QMI_UIM_PERSO_FEATURE_GW_NETW_SUBSET_PERSO] = "GW_netw_subset_perso",
+[QMI_UIM_PERSO_FEATURE_GW_SP_PERSO]          = "GW_SP_perso",
+[QMI_UIM_PERSO_FEATURE_GW_CORP_PERSO]        = "GW_Corp_perso",
+[QMI_UIM_PERSO_FEATURE_GW_UIM_PERSO]         = "GW_UIM_perso",
+[QMI_UIM_PERSO_FEATURE_1X_NW_TYPE1_PERSO]    = "1X_NW_type1_perso",
+[QMI_UIM_PERSO_FEATURE_1X_NW_TYPE2_PERSO]    = "1X_NW_type2_perso",
+[QMI_UIM_PERSO_FEATURE_1X_HRPD_PERSO]        = "1X_HRPD_perso",
+[QMI_UIM_PERSO_FEATURE_1X_SP_PERSO]          = "1X_SP_perso",
+[QMI_UIM_PERSO_FEATURE_1X_CORP_PERSO]        = "1X_Corp_perso",
+[QMI_UIM_PERSO_FEATURE_1X_RUIM_PERSO]        = "1X_UIM_perso",
+[QMI_UIM_PERSO_FEATURE_UNKNOWN]              = "unknown",
+};
+
+const char *universal_pin[] = {
+[QMI_UIM_UNIV_PIN_PIN1] = "PIN1",
+[QMI_UIM_UNIV_PIN_UPIN] = "UPIN",
+};
+
+const char *hot_swap[] = {
+[QMI_UIM_HOT_SWAP_NOT_SUPPORTED]        = "not_supported",
+[QMI_UIM_HOT_SWAP_SWITCH_NOT_SUPPORTED] = "switch_not_supported",
+[QMI_UIM_HOT_SWAP_CARD_PRESENT]         = "card_present",
+[QMI_UIM_HOT_SWAP_CARD_NOT_PRESENT]     = "card_not_present",
+};
+
+static void cmd_uim_get_card_status_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+{
+	struct qmi_uim_get_card_status_response res;
+	void *c;
+	int state;
+	int i;
+	char field[128];
+
+	qmi_parse_uim_get_card_status_response(msg, &res);
+
+	c = blobmsg_open_table(&status, NULL);
+	if (res.set.card_status) {
+		blobmsg_add_u32(&status, "index_gw_pri", (int32_t)res.data.card_status.index_gw_pri);
+		blobmsg_add_u32(&status, "index_lx_pri", (int32_t)res.data.card_status.index_lx_pri);
+		blobmsg_add_u32(&status, "index_gw_sec", (int32_t)res.data.card_status.index_gw_sec);
+		blobmsg_add_u32(&status, "index_lx_sec", (int32_t)res.data.card_status.index_lx_sec);
+		blobmsg_add_u32(&status, "num_slot", (int32_t)res.data.card_status.num_slot);
+		state = res.data.card_status.card_state;
+		if (state > QMI_UIM_CARD_STATE_ERROR)
+			state = QMI_UIM_CARD_STATE_ERROR;
+		blobmsg_add_string(&status, "card_state", card_state[state]);
+		state = res.data.card_status.upin_state;
+		if (state > QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED)
+			state = QMI_UIM_PIN_STATE_UNKNOWN;
+		blobmsg_add_string(&status, "upin_state", pin_state[state]);
+		blobmsg_add_u32(&status, "upin_retries", (int32_t)res.data.card_status.upin_retries);
+		blobmsg_add_u32(&status, "upuk_retries", (int32_t)res.data.card_status.upuk_retries);
+		state = res.data.card_status.error_code;
+		if (state > QMI_UIM_ERROR_CODE_TECHNICAL_PROBLEMS)
+			state = QMI_UIM_ERROR_CODE_UNKNOWN;
+		blobmsg_add_string(&status, "error_code", error_code[state]);
+		blobmsg_add_u32(&status, "num_app", (int32_t)res.data.card_status.num_app);
+		state = res.data.card_status.app_type;
+		if (state > QMI_UIM_APP_TYPE_ISIM_APPLICATION)
+			state = QMI_UIM_APP_TYPE_UNKNOWN;
+		blobmsg_add_string(&status, "app_type", app_type[state]);
+		state = res.data.card_status.app_state;
+		if (state > QMI_UIM_APP_STATE_READY)
+			state = QMI_UIM_APP_STATE_UNKNOWN;
+		blobmsg_add_string(&status, "app_state", app_state[state]);
+		state = res.data.card_status.perso_state;
+		if (state > QMI_UIM_PERSO_STATE_PERMANENTLY_BLOCKED)
+			state = QMI_UIM_PERSO_STATE_UNKNOWN;
+		blobmsg_add_string(&status, "perso_state", perso_state[state]);
+		state = res.data.card_status.perso_feature;
+		if (state > QMI_UIM_PERSO_FEATURE_UNKNOWN)
+			state = QMI_UIM_PERSO_FEATURE_UNKNOWN;
+		blobmsg_add_string(&status, "perso_feature", perso_feature[state]);
+		blobmsg_add_u32(&status, "perso_retries", (int32_t)res.data.card_status.perso_retries);
+		blobmsg_add_u32(&status, "perso_unblock_retries", (int32_t)res.data.card_status.perso_unblock_retries);
+		blobmsg_add_u32(&status, "aid_len", (int32_t)res.data.card_status.aid_len);
+/*
+ * Currently do not parse the aid_value; it is of little use.
+ */
+		state = res.data.card_status.univ_pin;
+		if ((state < QMI_UIM_UNIV_PIN_PIN1 ) || (state > QMI_UIM_UNIV_PIN_UPIN))
+			state = QMI_UIM_UNIV_PIN_UPIN;
+		blobmsg_add_string(&status, "univ_pin", universal_pin[state]);
+		state = res.data.card_status.pin1_state;
+		if ((state < QMI_UIM_PIN_STATE_UNKNOWN) || (state > QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED))
+			state = QMI_UIM_PIN_STATE_UNKNOWN;
+		blobmsg_add_string(&status, "pin1_state", pin_state[state]);
+		blobmsg_add_u32(&status, "pin1_retries", (int32_t)res.data.card_status.pin1_retries);
+		blobmsg_add_u32(&status, "puk1_retries", (int32_t)res.data.card_status.puk1_retries);
+		state = res.data.card_status.pin2_state;
+		if ((state < QMI_UIM_PIN_STATE_UNKNOWN) || (state > QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED))
+			state = QMI_UIM_PIN_STATE_UNKNOWN;
+		blobmsg_add_string(&status, "pin2_state", pin_state[state]);
+		blobmsg_add_u32(&status, "pin2_retries", (int32_t)res.data.card_status.pin2_retries);
+		blobmsg_add_u32(&status, "puk2_retries", (int32_t)res.data.card_status.puk2_retries);
+	}
+
+	if (res.set.hot_swap_status) {
+		blobmsg_add_u32(&status, "hot_swap_len", (int32_t)res.data.hot_swap_status.hot_swap_len);
+		for (i = 0; i < res.data.hot_swap_status.hot_swap_len; ++i) {
+			sprintf(field, "hot_swap[%d]", i);
+			state = res.data.hot_swap_status.hot_swap[i];
+			if (state > QMI_UIM_HOT_SWAP_CARD_NOT_PRESENT)
+				state = QMI_UIM_HOT_SWAP_NOT_SUPPORTED;
+			blobmsg_add_string(&status, field, hot_swap[state]);
+		}
+	}
+
+	if (res.set.valid_card_status) {
+		blobmsg_add_u32(&status, "card_status_validity_len", (int32_t)res.data.valid_card_status.card_status_validity_len);
+		for (i = 0; i < res.data.valid_card_status.card_status_validity_len; ++i) {
+			sprintf(field, "card_status_validity[%d]", i);
+			if (res.data.valid_card_status.card_status_validity[i])
+				blobmsg_add_string(&status, field, "true");
+			else
+				blobmsg_add_string(&status, field, "false");
+		}
+	}
+
+	blobmsg_close_table(&status, c);
+}
+
+static enum qmi_cmd_result
+cmd_uim_get_card_status_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	qmi_set_uim_get_card_status_request(msg);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_verify_pin1_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_verify_pin1_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	struct qmi_uim_verify_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(verify_pin,
+			.pin_id = QMI_UIM_PIN_ID_PIN1,
+			.pin_len = strlen(arg),
+			.pin_value = (uint8_t *)arg
+		)
+	};
+
+	qmi_set_uim_verify_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_verify_pin2_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_verify_pin2_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	struct qmi_uim_verify_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(verify_pin,
+			.pin_id = QMI_UIM_PIN_ID_PIN2,
+			.pin_len = strlen(arg),
+			.pin_value = (uint8_t *)arg
+		)
+	};
+
+	qmi_set_uim_verify_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+
+#define cmd_uim_set_pin1_protect_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_set_pin1_protect_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	QmiUimPinOperation pin_operation;
+
+	if (!uim_req_data.pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	if (strcmp(arg, "enabled") == 0) {
+		pin_operation = QMI_UIM_ENABLE_PIN;
+	}
+	else {
+		pin_operation = QMI_UIM_DISABLE_PIN;
+	}
+	struct qmi_uim_set_pin_protection_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(pin_protection,
+			.pin_id = QMI_UIM_PIN_ID_PIN1,
+			.pin_operation = pin_operation,
+			.pin_len = uim_req_data.pin_len,
+		),
+		QMI_INIT_PTR(pin_protection.pin_value, uim_req_data.pin_value)
+	};
+
+	qmi_set_uim_set_pin_protect_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_set_pin2_protect_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_set_pin2_protect_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	QmiUimPinOperation pin_operation;
+
+	if (!uim_req_data.pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	if (strcmp(arg, "enabled")) {
+		pin_operation = QMI_UIM_ENABLE_PIN;
+	}
+	else {
+		pin_operation = QMI_UIM_DISABLE_PIN;
+	}
+	struct qmi_uim_set_pin_protection_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(pin_protection,
+			.pin_id = QMI_UIM_PIN_ID_PIN2,
+			.pin_operation = pin_operation,
+			.pin_len = uim_req_data.pin_len,
+		),
+		QMI_INIT_PTR(pin_protection.pin_value, uim_req_data.pin_value)
+	};
+
+	qmi_set_uim_set_pin_protect_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#if 0
+static enum qmi_cmd_result
+cmd_uim_change_pin_prepare(struct qmi_msg *msg, char *arg)
+{
+	if (!uim_req_data.pin_value || !uim_req_data.new_pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	struct qmi_uim_change_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(change_pin,
+			.pin_id = uim_req_data.pin_id,
+			.old_pin_len = uim_req_data.pin_len,
+			.new_pin_len = uim_req_data.new_pin_len,
+		),
+		QMI_INIT_PTR(change_pin.old_pin_value, uim_req_data.pin_value),
+		QMI_INIT_PTR(change_pin.new_pin_value, uim_req_data.new_pin_value)
+	};
+
+	qmi_set_uim_change_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_change_pin1_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_change_pin1_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	uim_req_data.pin_id = QMI_UIM_PIN_ID_PIN1;
+	return cmd_uim_change_pin_prepare(msg, arg);
+}
+
+#define cmd_uim_change_pin2_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_change_pin2_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	uim_req_data.pin_id = QMI_UIM_PIN_ID_PIN2;
+	return cmd_uim_change_pin_prepare(msg, arg);
+}
+#else
+#define cmd_uim_change_pin1_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_change_pin1_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	if (!uim_req_data.pin_value || !uim_req_data.new_pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	struct qmi_uim_change_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(change_pin,
+			.pin_id = QMI_UIM_PIN_ID_PIN1,
+			.old_pin_len = uim_req_data.pin_len,
+			.new_pin_len = uim_req_data.new_pin_len,
+		),
+		QMI_INIT_PTR(change_pin.old_pin_value, uim_req_data.pin_value),
+		QMI_INIT_PTR(change_pin.new_pin_value, uim_req_data.new_pin_value)
+	};
+
+	qmi_set_uim_change_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_change_pin2_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_change_pin2_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	if (!uim_req_data.pin_value || !uim_req_data.new_pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	struct qmi_uim_change_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(change_pin,
+			.pin_id = QMI_UIM_PIN_ID_PIN2,
+			.old_pin_len = uim_req_data.pin_len,
+			.new_pin_len = uim_req_data.new_pin_len,
+		),
+		QMI_INIT_PTR(change_pin.old_pin_value, uim_req_data.pin_value),
+		QMI_INIT_PTR(change_pin.new_pin_value, uim_req_data.new_pin_value)
+	};
+
+	qmi_set_uim_change_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+#endif
+
+#define cmd_uim_set_upin_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_set_upin_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	uim_req_data.pin_len = strlen(arg);
+	uim_req_data.pin_value = (uint8_t *)arg;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_uim_set_unew_pin_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_set_unew_pin_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	uim_req_data.new_pin_len = strlen(arg);
+	uim_req_data.new_pin_value = (uint8_t *)arg;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_uim_set_upuk_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_set_upuk_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	uim_req_data.puk_len = strlen(arg);
+	uim_req_data.puk_value = (uint8_t *)arg;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_uim_unblock_pin1_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_unblock_pin1_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	if (!uim_req_data.puk_value || !uim_req_data.pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	struct qmi_uim_unblock_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(unblock_pin,
+			.pin_id = QMI_UIM_PIN_ID_PIN1,
+			.puk_len = uim_req_data.puk_len,
+			.new_pin_len =uim_req_data.pin_len
+			),
+		QMI_INIT_PTR(unblock_pin.puk_value, uim_req_data.puk_value),
+		QMI_INIT_PTR(unblock_pin.new_pin_value, uim_req_data.pin_value)
+		};
+
+	qmi_set_uim_unblock_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_unblock_pin2_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_unblock_pin2_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	if (!uim_req_data.puk_value || !uim_req_data.pin_value) {
+		uqmi_add_error("Missing argument");
+		return QMI_CMD_EXIT;
+	}
+
+	struct qmi_uim_unblock_pin_request data = {
+		QMI_INIT_SEQUENCE(session_information,
+			.session_type = QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING,
+			.aid_len = 0
+		),
+		QMI_INIT_SEQUENCE(unblock_pin,
+			.pin_id = QMI_UIM_PIN_ID_PIN2,
+			.puk_len = uim_req_data.puk_len,
+			.new_pin_len =uim_req_data.pin_len
+			),
+		QMI_INIT_PTR(unblock_pin.puk_value, uim_req_data.puk_value),
+		QMI_INIT_PTR(unblock_pin.new_pin_value, uim_req_data.pin_value)
+		};
+
+	qmi_set_uim_unblock_pin_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
--- a/main.c
+++ b/main.c
@@ -56,7 +56,7 @@ static int usage(const char *progname)
 		"  --keep-client-id <name>:          Keep Client ID for service <name>\n"
 		"  --release-client-id <name>:       Release Client ID after exiting\n"
 		"\n"
-		"Services:                           dms, nas, pds, wds, wms\n"
+		"Services:                           dms, nas, pds, wds, wms, uim\n"
 		"\n"
 		"Actions:\n"
 		"  --get-versions:                   Get service versions\n"
@@ -66,6 +66,7 @@ static int usage(const char *progname)
 		"                                    (implies --keep-client-id)\n"
 		wds_helptext
 		dms_helptext
+		uim_helptext
 		nas_helptext
 		wms_helptext
 		wda_helptext
--- a/qmi-enums-uim.h
+++ b/qmi-enums-uim.h
@@ -0,0 +1,312 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * uqmi -- tiny QMI support implementation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2012 Lanedo GmbH <aleksander@lanedo.com>
+ */
+
+#ifndef _LIBQMI_GLIB_QMI_ENUMS_UIM_H_
+#define _LIBQMI_GLIB_QMI_ENUMS_UIM_H_
+
+/**
+ * SECTION: qmi-enums-uim
+ * @title: UIM enumerations and flags
+ *
+ * This section defines enumerations and flags used in the UIM service
+ * interface.
+ */
+
+/*****************************************************************************/
+/* Helper enums for the 'QMI UIM Get Card status' message */
+
+/**
+ * QmiUimCardState:
+ * @QMI_UIM_CARD_STATE_ABSENT: UIM card not present.
+ * @QMI_UIM_CARD_STATE_PRESENT: UIM card present.
+ * @QMI_UIM_CARD_STATE_ERROR: UIM card error.
+ *
+ * Card state.
+ */
+typedef enum {
+    QMI_UIM_CARD_STATE_ABSENT  = 0,
+    QMI_UIM_CARD_STATE_PRESENT = 1,
+    QMI_UIM_CARD_STATE_ERROR   = 2
+} QmiUimCardState;
+
+/**
+ * QmiUimPinState:
+ * @QMI_UIM_PIN_STATE_UNKNOWN: PIN state unknown.
+ * @QMI_UIM_PIN_STATE_ENABLED_NOT_VERIFIED: PIN state enabled but not verified.
+ * @QMI_UIM_PIN_STATE_ENABLED_VERIFIED: PIN state enabled and verified.
+ * @QMI_UIM_PIN_STATE_DISABLED: PIN state disabled.
+ * @QMI_UIM_PIN_STATE_BLOCKED: PIN state blocked.
+ * @QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED: PIN state permanently blocked.
+ *
+ * Pin state.
+ */
+ typedef enum {
+    QMI_UIM_PIN_STATE_UNKNOWN              = 0,
+    QMI_UIM_PIN_STATE_ENABLED_NOT_VERIFIED = 1,
+    QMI_UIM_PIN_STATE_ENABLED_VERIFIED     = 2,
+    QMI_UIM_PIN_STATE_DISABLED             = 3,
+    QMI_UIM_PIN_STATE_BLOCKED              = 4,
+    QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED  = 5
+ } QmiUimPinState;
+
+/**
+ * QmiUimErrorCode:
+ * @QMI_UIM_ERROR_CODE_UNKNOWN: Unknown.
+ * @QMI_UIM_ERROR_CODE_POWER_DOWN: Power down.
+ * @QMI_UIM_ERROR_CODE_POLL_ERROR:Poll error
+ * @QMI_UIM_ERROR_CODE_NO_ATR_RECEIVED: No ATR received.
+ * @QMI_UIM_ERROR_CODE_VOLT_MISMATCH: Volt mismatch.
+ * @QMI_UIM_ERROR_CODE_PARITY_ERROR: Parity error.
+ * @QMI_UIM_ERROR_CODE_POSSIBLY_REMOVED: Unknown, possibly removed.
+ * @QMI_UIM_ERROR_CODE_TECHNICAL_PROBLEMS: Technical problems.
+ *
+ * Error code.
+ */
+
+ typedef enum {
+    QMI_UIM_ERROR_CODE_UNKNOWN            = 0,
+    QMI_UIM_ERROR_CODE_POWER_DOWN         = 1,
+    QMI_UIM_ERROR_CODE_POLL_ERROR         = 2,
+    QMI_UIM_ERROR_CODE_NO_ATR_RECEIVED    = 3,
+    QMI_UIM_ERROR_CODE_VOLT_MISMATCH      = 4,
+    QMI_UIM_ERROR_CODE_PARITY_ERROR       = 5,
+    QMI_UIM_ERROR_CODE_POSSIBLY_REMOVED   = 6,
+    QMI_UIM_ERROR_CODE_TECHNICAL_PROBLEMS = 7
+} QmiUimErrorCode;
+
+/**
+ * QmiUimAppType:
+ * @QMI_UIM_APP_TYPE_UNKNOWN: Unknown
+ * @QMI_UIM_APP_TYPE_SIM_CARD: SIM card
+ * @QMI_UIM_APP_TYPE_USIM_APPLICATION: USIM application
+ * @QMI_UIM_APP_TYPE_RUIM_CARD: RUIM card
+ * @QMI_UIM_APP_TYPE_CSIM_APPLICATION: CSIM application
+ * @QMI_UIM_APP_TYPE_ISIM_APPLICATION: ISIM application
+ *
+ * App type.
+ */
+
+typedef enum {
+    QMI_UIM_APP_TYPE_UNKNOWN          = 0,
+    QMI_UIM_APP_TYPE_SIM_CARD          =1,
+    QMI_UIM_APP_TYPE_USIM_APPLICATION = 2,
+    QMI_UIM_APP_TYPE_RUIM_CARD        = 3,
+    QMI_UIM_APP_TYPE_CSIM_APPLICATION = 4,
+    QMI_UIM_APP_TYPE_ISIM_APPLICATION = 5
+} QmiUimAppType;
+
+
+/**
+ * QmiUimAppState:
+ * @QMI_UIM_APP_STATE_UNKNOWN: Unknown
+ * @QMI_UIM_APP_STATE_DETECTED: Detected
+ * @QMI_UIM_APP_STATE_PIN_REQUIRED: PIN1 or UPIN is required
+ * @QMI_UIM_APP_STATE_PUK_REQUIRED: PUK1 or PUK for UPIN is required
+ * @QMI_UIM_APP_STATE_CHECK_PERSO_STATE: Personalization state must be checked
+ * @QMI_UIM_APP_STATE_PIN1_BLOCKED: PIN1 is blocked
+ * @QMI_UIM_APP_STATE_ILLEGAL: Illegal
+ * @QMI_UIM_APP_STATE_READY: Ready
+ *
+ * App state.
+ */
+
+typedef enum {
+    QMI_UIM_APP_STATE_UNKNOWN           = 0,
+    QMI_UIM_APP_STATE_DETECTED          = 1,
+    QMI_UIM_APP_STATE_PIN_REQUIRED      = 2,
+    QMI_UIM_APP_STATE_PUK_REQUIRED      = 3,
+    QMI_UIM_APP_STATE_CHECK_PERSO_STATE = 4,
+    QMI_UIM_APP_STATE_PIN1_BLOCKED      = 5,
+    QMI_UIM_APP_STATE_ILLEGAL           = 6,
+    QMI_UIM_APP_STATE_READY             = 7
+} QmiUimAppState;
+
+/**
+ * QmiUimPersoState:
+ * @QMI_UIM_PERSO_STATE_UNKNOWN: Unknown
+ * @QMI_UIM_PERSO_STATE_PERSO_OP_IN_PROGRESS: Personalization operation is in progress
+ * @QMI_UIM_PERSO_STATE_READY: Ready
+ * @QMI_UIM_PERSO_STATE_PERSO_CODE_REQUIRED: Personalization code is required
+ * @QMI_UIM_PERSO_STATE_PUK_FOR_PERSO_CODE_REQUIRED: PUK for personalization code is required
+ * @QMI_UIM_PERSO_STATE_PERMANENTLY_BLOCKED: Permanently blocked
+ *
+ * Perso state.
+ */
+
+typedef enum {
+    QMI_UIM_PERSO_STATE_UNKNOWN                     = 0,
+    QMI_UIM_PERSO_STATE_PERSO_OP_IN_PROGRESS        = 1,
+    QMI_UIM_PERSO_STATE_READY                       = 2,
+    QMI_UIM_PERSO_STATE_PERSO_CODE_REQUIRED         = 3,
+    QMI_UIM_PERSO_STATE_PUK_FOR_PERSO_CODE_REQUIRED = 4,
+    QMI_UIM_PERSO_STATE_PERMANENTLY_BLOCKED         = 5
+} QmiUimPersoState;
+
+/**
+ * QmiUimPersoFeature:
+ * @QMI_UIM_PERSO_FEATURE_GW_NETW_PERSO: GW network personalization
+ * @QMI_UIM_PERSO_FEATURE_GW_NETW_SUBSET_PERSO: GW network subset personalization
+ * @QMI_UIM_PERSO_FEATURE_GW_SP_PERSO: GW service provider personalization
+ * @QMI_UIM_PERSO_FEATURE_GW_CORP_PERSO: GW corporate personalization
+ * @QMI_UIM_PERSO_FEATURE_GW_UIM_PERSO: GW UIM personalization
+ * @QMI_UIM_PERSO_FEATURE_1X_NW_TYPE1_PERSO: 1X network type 1 personalization
+ * @QMI_UIM_PERSO_FEATURE_1X_NW_TYPE2_PERSO: 1X network type 2 personalization
+ * @QMI_UIM_PERSO_FEATURE_1X_HRPD_PERSO: 1X HRPD personalization
+ * @QMI_UIM_PERSO_FEATURE_1X_SP_PERSO: 1X service provider personalization
+ * @QMI_UIM_PERSO_FEATURE_1X_CORP_PERSO: 1X corporate personalization
+ * @QMI_UIM_PERSO_FEATURE_1X_RUIM_PERSO: 1X RUIM personalization
+ * @QMI_UIM_PERSO_FEATURE_UNKNOWN: Unknown
+ *
+ * Perso feature.
+ */
+
+typedef enum {
+    QMI_UIM_PERSO_FEATURE_GW_NETW_PERSO        = 0,
+    QMI_UIM_PERSO_FEATURE_GW_NETW_SUBSET_PERSO = 1,
+    QMI_UIM_PERSO_FEATURE_GW_SP_PERSO          = 2,
+    QMI_UIM_PERSO_FEATURE_GW_CORP_PERSO        = 3,
+    QMI_UIM_PERSO_FEATURE_GW_UIM_PERSO         = 4,
+    QMI_UIM_PERSO_FEATURE_1X_NW_TYPE1_PERSO    = 5,
+    QMI_UIM_PERSO_FEATURE_1X_NW_TYPE2_PERSO    = 6,
+    QMI_UIM_PERSO_FEATURE_1X_HRPD_PERSO        = 7,
+    QMI_UIM_PERSO_FEATURE_1X_SP_PERSO          = 8,
+    QMI_UIM_PERSO_FEATURE_1X_CORP_PERSO        = 9,
+    QMI_UIM_PERSO_FEATURE_1X_RUIM_PERSO        = 10,
+    QMI_UIM_PERSO_FEATURE_UNKNOWN              = 11
+} QmiUimPersoFeature;
+
+/**
+ * QmiUimUnivPin:
+ * @QMI_UIM_UNIV_PIN_PIN1: PIN1 is used
+ * @QMI_UIM_UNIV_PIN_UPIN: UPIN replaces PIN1
+ *
+ * Univ PIN.
+ */
+
+typedef enum {
+    QMI_UIM_UNIV_PIN_PIN1 = 0,
+    QMI_UIM_UNIV_PIN_UPIN = 1
+} QmiUimUnivPin;
+
+/**
+ * QmiUimHotSwap:
+ * @QMI_UIM_HOT_SWAP_NOT_SUPPORTED: Hot-swap is not supported
+ * @QMI_UIM_HOT_SWAP_SWITCH_NOT_SUPPORTED: Hot-swap is supported, but the status of the switch is not supported
+ * @QMI_UIM_HOT_SWAP_CARD_PRESENT: Switch indicates that the card is present
+ * @QMI_UIM_HOT_SWAP_CARD_NOT_PRESENT: Switch indicates that the card is not present
+ *
+ * Hot swap.
+ */
+
+typedef enum {
+    QMI_UIM_HOT_SWAP_NOT_SUPPORTED        = 0,
+    QMI_UIM_HOT_SWAP_SWITCH_NOT_SUPPORTED = 1,
+    QMI_UIM_HOT_SWAP_CARD_PRESENT         = 2,
+    QMI_UIM_HOT_SWAP_CARD_NOT_PRESENT     = 3
+} QmiUimHotSwap;
+
+/**
+ * QmiUimSessionType:
+ * @QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING: Primary GW provisioning
+ * @QMI_UIM_SESSION_TYPE_PRI_1X_PROVISIONING: Primary 1X provisioning
+ * @QMI_UIM_SESSION_TYPE_SEC_GW_PROVISIONING: Secondary GW provisioning
+ * @QMI_UIM_SESSION_TYPE_SEC_1X_PROVISIONING: Secondary 1X provisioning
+ * @QMI_UIM_SESSION_TYPE_NON_PROVISIONING_ON_SLOT1: Nonprovisioning on slot 1
+ * @QMI_UIM_SESSION_TYPE_NON_PROVISIONING_ON_SLOT2: Nonprovisioning on slot 2
+ * @QMI_UIM_SESSION_TYPE_CARD_ON_SLOT1: Card on slot 1
+ * @QMI_UIM_SESSION_TYPE_CARD_ON_SLOT2: Card on slot 2
+ * @QMI_UIM_SESSION_TYPE_LOGIC_CHAN_ON_SLOT1: Logical channel on slot 1
+ * @QMI_UIM_SESSION_TYPE_LOGIC_CHAN_ON_SLOT2: Logical channel on slot 2
+*
+ * Session type.
+ */
+
+typedef enum {
+    QMI_UIM_SESSION_TYPE_PRI_GW_PROVIVIONING       = 0,
+    QMI_UIM_SESSION_TYPE_PRI_1X_PROVISIONING       = 1,
+    QMI_UIM_SESSION_TYPE_SEC_GW_PROVISIONING       = 2,
+    QMI_UIM_SESSION_TYPE_SEC_1X_PROVISIONING       = 3,
+    QMI_UIM_SESSION_TYPE_NON_PROVISIONING_ON_SLOT1 = 4,
+    QMI_UIM_SESSION_TYPE_NON_PROVISIONING_ON_SLOT2 = 5,
+    QMI_UIM_SESSION_TYPE_CARD_ON_SLOT1             = 6,
+    QMI_UIM_SESSION_TYPE_CARD_ON_SLOT2             = 7,
+    QMI_UIM_SESSION_TYPE_LOGIC_CHAN_ON_SLOT1       = 8,
+    QMI_UIM_SESSION_TYPE_LOGIC_CHAN_ON_SLOT2       = 9
+} QmiUimSessionType;
+
+/**
+ * QmiUimPinID:
+ * @QMI_UIM_PIN_ID_PIN1: PIN1 (also called PIN)
+ * @QMI_UIM_PIN_ID_PIN2: PIN2
+ * @QMI_UIM_PIN_ID_UPIN: Universal PIN
+ * @QMI_UIM_PIN_ID_HIDDEN_KEY: Hidden key
+*
+ * PIN id.
+ */
+
+typedef enum {
+    QMI_UIM_PIN_ID_PIN1       = 1,
+    QMI_UIM_PIN_ID_PIN2       = 2,
+    QMI_UIM_PIN_ID_UPIN       = 3,
+    QMI_UIM_PIN_ID_HIDDEN_KEY = 4
+} QmiUimPinID;
+
+/**
+ * QmiUimPinOperation:
+ * @QMI_UIM_DISABLE_PIN: Disable the PIN
+ * @QMI_UIM_ENABLE_PIN:  Enable the PIN
+*
+ * PIN Operation.
+ */
+
+typedef enum {
+    QMI_UIM_DISABLE_PIN = 0,
+    QMI_UIM_ENABLE_PIN  = 1
+} QmiUimPinOperation;
+
+/**
+ * QmiUimPinKeyRefID:
+ * @QMI_UIM_PIN_KEY_REF_ID_APP1: For application 1
+ * @QMI_UIM_PIN_KEY_REF_ID_APP2: For application 2
+ * @QMI_UIM_PIN_KEY_REF_ID_APP3: For application 3
+ * @QMI_UIM_PIN_KEY_REF_ID_APP4: For application 4
+ * @QMI_UIM_PIN_KEY_REF_ID_APP5: For application 5
+ * @QMI_UIM_PIN_KEY_REF_ID_APP6: For application 6
+ * @QMI_UIM_PIN_KEY_REF_ID_APP7: For application 7
+ * @QMI_UIM_PIN_KEY_REF_ID_APP8: For application 8
+*
+ * PIN key ref id.
+ */
+
+typedef enum {
+    QMI_UIM_PIN_KEY_REF_ID_APP1 = 1,
+    QMI_UIM_PIN_KEY_REF_ID_APP2 = 2,
+    QMI_UIM_PIN_KEY_REF_ID_APP3 = 3,
+    QMI_UIM_PIN_KEY_REF_ID_APP4 = 4,
+    QMI_UIM_PIN_KEY_REF_ID_APP5 = 5,
+    QMI_UIM_PIN_KEY_REF_ID_APP6 = 6,
+    QMI_UIM_PIN_KEY_REF_ID_APP7 = 7,
+    QMI_UIM_PIN_KEY_REF_ID_APP8 = 8
+} QmiUimPinKeyRefID;
+
+#endif /* _LIBQMI_GLIB_QMI_ENUMS_UIM_H_ */
+
--- a/qmi-message.h
+++ b/qmi-message.h
@@ -51,6 +51,9 @@
 #include "qmi-enums-wda.h"
 #include "qmi-message-wda.h"

+#include "qmi-enums-uim.h"
+#include "qmi-message-uim.h"
+
 #define qmi_set(_data, _field, _val) \
 	do { \
 		(_data)->set._field = 1; \
--- a/qmi-message-uim.h
+++ b/qmi-message-uim.h
@@ -0,0 +1,159 @@
+struct qmi_uim_get_card_status_response {
+	struct {
+		unsigned int card_status : 1;
+		unsigned int hot_swap_status : 1;
+		unsigned int valid_card_status : 1;
+	} set;
+	struct {
+		struct {
+			uint16_t           index_gw_pri;
+			uint16_t           index_lx_pri;
+			uint16_t           index_gw_sec;
+			uint16_t           index_lx_sec;
+			uint8_t            num_slot;
+			QmiUimCardState    card_state;
+			QmiUimPinState     upin_state;
+			uint8_t            upin_retries;
+			uint8_t            upuk_retries;
+			QmiUimErrorCode    error_code;
+			uint8_t            num_app;
+			QmiUimAppType      app_type;
+			QmiUimAppState     app_state;
+			QmiUimPersoState   perso_state;
+			QmiUimPersoFeature perso_feature;
+			uint8_t            perso_retries;
+			uint8_t            perso_unblock_retries;
+			uint8_t            aid_len;
+			uint8_t           *aid_value;
+			QmiUimUnivPin      univ_pin;
+			QmiUimPinState     pin1_state;
+			uint8_t            pin1_retries;
+			uint8_t            puk1_retries;
+			QmiUimPinState     pin2_state;
+			uint8_t            pin2_retries;
+			uint8_t            puk2_retries;
+		} card_status;
+		struct {
+			uint8_t            hot_swap_len;
+			QmiUimHotSwap     *hot_swap;
+		} hot_swap_status;
+		struct {
+			uint8_t            card_status_validity_len;
+			bool              *card_status_validity;
+		} valid_card_status;
+	} data;
+};
+
+struct qmi_uim_verify_pin_request {
+	struct {
+		unsigned int session_information : 1;
+		unsigned int verify_pin : 1;
+		unsigned int encrypted_pin1 : 1;
+		unsigned int key_reference_id : 1;
+		unsigned int response_in_indication : 1;
+	} set;
+	struct {
+		struct {
+			QmiUimSessionType session_type;
+			uint8_t           aid_len;
+			uint8_t          *aid;
+		} session_information;
+		struct {
+			QmiUimPinID       pin_id;
+			uint8_t           pin_len;
+			uint8_t          *pin_value;
+		} verify_pin;
+		struct {
+			uint8_t           enc_pin1_len;
+			uint8_t          *enc_pin1_value;
+		} encrypted_pin1;
+		struct {
+			QmiUimPinKeyRefID pin_key_ref_id;
+		} key_reference_id;
+		struct {
+			uint32_t          indication_token;
+		} response_in_indication;
+	} data;
+};
+
+struct qmi_uim_set_pin_protection_request {
+	struct {
+		unsigned int session_information : 1;
+		unsigned int pin_protection : 1;
+	} set;
+	struct {
+		struct {
+			QmiUimSessionType  session_type;
+			uint8_t            aid_len;
+			uint8_t           *aid;
+		} session_information;
+		struct {
+			QmiUimPinID        pin_id;
+			QmiUimPinOperation pin_operation;
+			uint8_t            pin_len;
+			uint8_t           *pin_value;
+		} pin_protection;
+	} data;
+};
+
+struct qmi_uim_change_pin_request {
+	struct {
+		unsigned int session_information : 1;
+		unsigned int change_pin : 1;
+	} set;
+	struct {
+		struct {
+			QmiUimSessionType  session_type;
+			uint8_t            aid_len;
+			uint8_t           *aid;
+		} session_information;
+		struct {
+			QmiUimPinID        pin_id;
+			uint8_t            old_pin_len;
+			uint8_t           *old_pin_value;
+			uint8_t            new_pin_len;
+			uint8_t           *new_pin_value;
+		} change_pin;
+	} data;
+};
+
+struct qmi_uim_unblock_pin_request {
+	struct {
+		unsigned int session_information : 1;
+		unsigned int unblock_pin : 1;
+	} set;
+	struct {
+		struct {
+			QmiUimSessionType session_type;
+			uint8_t           aid_len;
+			uint8_t          *aid;
+		} session_information;
+		struct {
+			QmiUimPinID       pin_id;
+			uint8_t           puk_len;
+			uint8_t          *puk_value;
+			uint8_t           new_pin_len;
+			uint8_t          *new_pin_value;
+		} unblock_pin;
+	} data;
+};
+
+struct qmi_uim_unblock_pin_response {
+	struct {
+		unsigned int pin_retries_status : 1;
+	} set;
+	struct {
+		struct {
+			uint8_t verify_retries_left;
+			uint8_t unblock_retries_left;
+		} pin_retries_status;
+	} data;
+};
+
+int qmi_set_uim_get_card_status_request(struct qmi_msg *msg);
+int qmi_parse_uim_get_card_status_response(struct qmi_msg *msg, struct qmi_uim_get_card_status_response *res);
+int qmi_set_uim_verify_pin_request(struct qmi_msg *msg, struct qmi_uim_verify_pin_request *req);
+int qmi_set_uim_set_pin_protect_request(struct qmi_msg *msg, struct qmi_uim_set_pin_protection_request *req);
+int qmi_set_uim_change_pin_request(struct qmi_msg *msg, struct qmi_uim_change_pin_request *req);
+int qmi_set_uim_unblock_pin_request(struct qmi_msg *msg, struct qmi_uim_unblock_pin_request *req);
+
--- a/qmi-message-uim.c
+++ b/qmi-message-uim.c
@@ -0,0 +1,285 @@
+#include <stdio.h>
+#include <string.h>
+#include "qmi-message.h"
+
+#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
+#define copy_tlv(_val, _size) \
+	do { \
+		unsigned int __size = _size; \
+		if (__size > 0) \
+			memcpy(__qmi_alloc_static(__size), _val, __size); \
+	} while (0);
+
+#define put_tlv_var(_type, _val, _size) \
+	do { \
+		_type __var = _val; \
+		copy_tlv(&__var, _size); \
+	} while(0)
+
+
+int qmi_set_uim_get_card_status_request(struct qmi_msg *msg)
+{
+	qmi_init_request_message(msg, QMI_SERVICE_UIM);
+	msg->svc.message = cpu_to_le16(0x002F);
+
+	return 0;
+}
+
+int qmi_parse_uim_get_card_status_response(struct qmi_msg *msg, struct qmi_uim_get_card_status_response *res)
+{
+	void *tlv_buf = &msg->svc.tlv;
+	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
+	struct tlv *tlv;
+	int i;
+	uint32_t found[1] = {};
+
+	memset(res, 0, sizeof(*res));
+
+	__qmi_alloc_reset();
+	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
+		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
+		unsigned int ofs = 0;
+
+		switch(tlv->type) {
+		case 0x10:
+			if (found[0] & (1 << 0))
+				break;
+
+			found[0] |= (1 << 0);
+			res->set.card_status = 1;
+			res->data.card_status.index_gw_pri = le16_to_cpu(*(uint16_t *) get_next(2));
+			res->data.card_status.index_lx_pri = le16_to_cpu(*(uint16_t *) get_next(2));
+			res->data.card_status.index_gw_sec = le16_to_cpu(*(uint16_t *) get_next(2));
+			res->data.card_status.index_lx_sec = le16_to_cpu(*(uint16_t *) get_next(2));
+			res->data.card_status.num_slot = *(uint8_t *) get_next(1);
+			res->data.card_status.card_state = (QmiUimCardState)(*(uint8_t *) get_next(1));
+			res->data.card_status.upin_state = (QmiUimPinState)(*(uint8_t *) get_next(1));
+			res->data.card_status.upin_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.upuk_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.error_code = (QmiUimErrorCode)(*(uint8_t *) get_next(1));
+			res->data.card_status.num_app = *(uint8_t *) get_next(1);
+			res->data.card_status.app_type = (QmiUimAppType)(*(uint8_t *) get_next(1));
+			res->data.card_status.app_state = (QmiUimAppState)(*(uint8_t *) get_next(1));
+			res->data.card_status.perso_state = (QmiUimPersoState)(*(uint8_t *) get_next(1));
+			res->data.card_status.perso_feature = (QmiUimPersoFeature)(*(uint8_t *) get_next(1));
+			res->data.card_status.perso_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.perso_unblock_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.aid_len = *(uint8_t *) get_next(1);
+			res->data.card_status.aid_value = __qmi_alloc_static(res->data.card_status.aid_len * sizeof(res->data.card_status.aid_value[0]));
+			for(i = 0; i < res->data.card_status.aid_len; ++i) {
+				res->data.card_status.aid_value[i] = *(uint8_t *) get_next(1);
+			}
+			res->data.card_status.univ_pin =  (QmiUimUnivPin)(*(uint8_t *) get_next(1));
+			res->data.card_status.pin1_state = (QmiUimPinState)(*(uint8_t *) get_next(1));
+			res->data.card_status.pin1_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.puk1_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.pin2_state = (QmiUimPinState)(*(uint8_t *) get_next(1));
+			res->data.card_status.pin2_retries = *(uint8_t *) get_next(1);
+			res->data.card_status.puk2_retries = *(uint8_t *) get_next(1);
+			break;
+
+		case 0x11:
+
+			if (found[0] & (1 << 1))
+				break;
+
+			found[0] |= (1 << 1);
+			res->set.hot_swap_status = 1;
+			res->data.hot_swap_status.hot_swap_len = *(uint8_t *) get_next(1);
+			res->data.hot_swap_status.hot_swap = __qmi_alloc_static(res->data.hot_swap_status.hot_swap_len * sizeof(res->data.hot_swap_status.hot_swap[0]));
+			for(i = 0; i < res->data.hot_swap_status.hot_swap_len; ++i) {
+				res->data.hot_swap_status.hot_swap[i] = (QmiUimHotSwap)(*(uint8_t *) get_next(1));
+			}
+			break;
+
+		case 0x12:
+			if (found[0] & (1 << 2))
+				break;
+
+			found[0] |= (1 << 2);
+
+			res->set.valid_card_status = 1;
+			res->data.valid_card_status.card_status_validity_len = *(uint8_t *) get_next(1);
+			res->data.valid_card_status.card_status_validity = __qmi_alloc_static(res->data.valid_card_status.card_status_validity_len * sizeof(res->data.valid_card_status.card_status_validity[0]));
+			for(i = 0; i < res->data.valid_card_status.card_status_validity_len; ++i) {
+				res->data.valid_card_status.card_status_validity[i] = (bool)(*(uint8_t *) get_next(1));
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return 0;
+
+error_len:
+	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
+	        __func__, tlv->type, le16_to_cpu(tlv->len));
+	return QMI_ERROR_INVALID_DATA;
+}
+
+int qmi_set_uim_verify_pin_request(struct qmi_msg *msg, struct qmi_uim_verify_pin_request *req)
+{
+	qmi_init_request_message(msg, QMI_SERVICE_UIM);
+	msg->svc.message = cpu_to_le16(0x0026);
+
+	if (req->set.session_information) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimSessionType, req->data.session_information.session_type, 1);
+		put_tlv_var(uint8_t, req->data.session_information.aid_len, 1);
+		strncpy(__qmi_alloc_static(req->data.session_information.aid_len), (const char *)req->data.session_information.aid, req->data.session_information.aid_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x01, ofs, buf);
+	}
+
+	if (req->set.verify_pin) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimPinID, req->data.verify_pin.pin_id, 1);
+		put_tlv_var(uint8_t, req->data.verify_pin.pin_len, 1);
+		strncpy(__qmi_alloc_static(req->data.verify_pin.pin_len), (const char *)req->data.verify_pin.pin_value, req->data.verify_pin.pin_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x02, ofs, buf);
+	}
+	if (req->set.encrypted_pin1) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(uint8_t, req->data.encrypted_pin1.enc_pin1_len, 1);
+		strncpy(__qmi_alloc_static(req->data.encrypted_pin1.enc_pin1_len), (const char *)req->data.encrypted_pin1.enc_pin1_value, req->data.encrypted_pin1.enc_pin1_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x10, ofs, buf);
+	}
+
+	if (req->set.key_reference_id) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimPinKeyRefID, req->data.key_reference_id.pin_key_ref_id, 1);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x11, ofs, buf);
+	}
+
+	if (req->set.response_in_indication) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(uint32_t, req->data.response_in_indication.indication_token, 4);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x12, ofs, buf);
+	}
+
+	return 0;
+}
+
+int qmi_set_uim_set_pin_protect_request(struct qmi_msg *msg, struct qmi_uim_set_pin_protection_request *req)
+{
+	qmi_init_request_message(msg, QMI_SERVICE_UIM);
+	msg->svc.message = cpu_to_le16(0x0025);
+
+	if (req->set.session_information) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimSessionType, req->data.session_information.session_type, 1);
+		put_tlv_var(uint8_t, req->data.session_information.aid_len, 1);
+		strncpy(__qmi_alloc_static(req->data.session_information.aid_len), (const char *)req->data.session_information.aid, req->data.session_information.aid_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x01, ofs, buf);
+	}
+
+	if (req->set.pin_protection) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimPinID, req->data.pin_protection.pin_id, 1);
+		put_tlv_var(QmiUimPinOperation, req->data.pin_protection.pin_operation, 1);
+		put_tlv_var(uint8_t, req->data.pin_protection.pin_len, 1);
+		strncpy(__qmi_alloc_static(req->data.pin_protection.pin_len), (const char *)req->data.pin_protection.pin_value, req->data.pin_protection.pin_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x02, ofs, buf);
+	}
+
+	return 0;
+}
+
+int qmi_set_uim_change_pin_request(struct qmi_msg *msg, struct qmi_uim_change_pin_request *req)
+{
+	qmi_init_request_message(msg, QMI_SERVICE_UIM);
+        msg->svc.message = cpu_to_le16(0x0028);
+
+	if (req->set.session_information) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimSessionType, req->data.session_information.session_type, 1);
+		put_tlv_var(uint8_t, req->data.session_information.aid_len, 1);
+		strncpy(__qmi_alloc_static(req->data.session_information.aid_len), (const char *)req->data.session_information.aid, req->data.session_information.aid_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x01, ofs, buf);
+	}
+
+	if (req->set.change_pin) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimPinID, req->data.change_pin.pin_id, 1);
+		put_tlv_var(uint8_t, req->data.change_pin.old_pin_len, 1);
+		strncpy(__qmi_alloc_static(req->data.change_pin.old_pin_len), (const char *)req->data.change_pin.old_pin_value, req->data.change_pin.old_pin_len);
+		put_tlv_var(uint8_t, req->data.change_pin.new_pin_len, 1);
+		strncpy(__qmi_alloc_static(req->data.change_pin.new_pin_len), (const char *)req->data.change_pin.new_pin_value, req->data.change_pin.new_pin_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x02, ofs, buf);
+	}
+
+	return 0;
+}
+
+int qmi_set_uim_unblock_pin_request(struct qmi_msg *msg, struct qmi_uim_unblock_pin_request *req)
+{
+	qmi_init_request_message(msg, QMI_SERVICE_UIM);
+	msg->svc.message = cpu_to_le16(0x0027);
+
+	if (req->set.session_information) {
+		void *buf;
+		unsigned int ofs;
+
+		__qmi_alloc_reset();
+		put_tlv_var(QmiUimSessionType, req->data.session_information.session_type, 1);
+		put_tlv_var(uint8_t, req->data.session_information.aid_len, 1);
+		strncpy(__qmi_alloc_static(req->data.session_information.aid_len), (const char *)req->data.session_information.aid, req->data.session_information.aid_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x01, ofs, buf);
+	}
+
+	if (req->set.unblock_pin) {
+		__qmi_alloc_reset();
+		void *buf;
+		unsigned int ofs;
+
+		put_tlv_var(uint8_t, req->data.unblock_pin.pin_id, 1);
+		put_tlv_var(uint8_t, req->data.unblock_pin.puk_len, 1);
+		strncpy(__qmi_alloc_static(req->data.unblock_pin.puk_len), (const char *)req->data.unblock_pin.puk_value, req->data.unblock_pin.puk_len);
+		put_tlv_var(uint8_t, req->data.unblock_pin.new_pin_len, 1);
+		strncpy(__qmi_alloc_static(req->data.unblock_pin.new_pin_len), (const char *)req->data.unblock_pin.new_pin_value, req->data.unblock_pin.new_pin_len);
+		buf = __qmi_get_buf(&ofs);
+		tlv_new(msg, 0x02, ofs, buf);
+	}
+
+	return 0;
+}
+
+
