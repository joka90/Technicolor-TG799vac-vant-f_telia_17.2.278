From 18cbefa668f465281f97859f5bb9d8ad12dc2a83 Mon Sep 17 00:00:00 2001
From: Alin Nastac <alin.nastac@technicolor.com>
Date: Wed, 27 Apr 2016 17:23:06 +0200
Subject: [PATCH] 310-tch-Add-dns-filter-feature.patch

---
 Makefile          |   3 +-
 src/auth.c        |  15 ++---
 src/cache.c       |  63 +++++++++++++++++---
 src/config.h      |   6 +-
 src/conntrack.c   |  12 +++-
 src/dhcp-common.c |   6 +-
 src/dhcp.c        |   2 +-
 src/dnsmasq.h     |  60 +++++++++++++++----
 src/filter.c      |  77 ++++++++++++++++++++++++
 src/forward.c     | 173 +++++++++++++++++++++++++++++++++++++++++++-----------
 src/network.c     |  18 +++++-
 src/option.c      | 122 ++++++++++++++++++++++++++++++++++++++
 src/rfc1035.c     |  37 ++++++------
 13 files changed, 507 insertions(+), 87 deletions(-)
 create mode 100644 src/filter.c

--- a/Makefile
+++ b/Makefile
@@ -76,7 +76,7 @@ objs = cache.o rfc1035.o util.o option.o
        helper.o tftp.o log.o conntrack.o dhcp6.o rfc3315.o \
        dhcp-common.o outpacket.o radv.o slaac.o auth.o ipset.o \
        domain.o dnssec.o blockdata.o tables.o loop.o inotify.o \
-       poll.o rrfilter.o edns0.o arp.o
+       poll.o rrfilter.o edns0.o arp.o filter.o
 
 hdrs = dnsmasq.h config.h dhcp-protocol.h dhcp6-protocol.h \
        dns-protocol.h radv-protocol.h ip6addr.h
--- a/src/auth.c
+++ b/src/auth.c
@@ -99,7 +99,7 @@ int in_zone(struct auth_zone *zone, char
 
 
 size_t answer_auth(struct dns_header *header, char *limit, size_t qlen, time_t now, union mysockaddr *peer_addr, 
-		   int local_query, int do_bit, int have_pseudoheader) 
+		   int local_query, int do_bit, int have_pseudoheader, const struct dns_filter *filter)
 {
   char *name = daemon->namebuff;
   unsigned char *p, *ansp;
@@ -118,6 +118,7 @@ size_t answer_auth(struct dns_header *he
   struct all_addr addr;
   struct cname *a, *candidate;
   unsigned int wclen;
+  int dnsset_id = filter ? filter->dnsset_id:0;
   
   if (ntohs(header->qdcount) == 0 || OPCODE(header) != QUERY )
     return 0;
@@ -220,7 +221,7 @@ size_t answer_auth(struct dns_header *he
 		}
 	    }
 	  
-	  if ((crecp = cache_find_by_addr(NULL, &addr, now, flag)))
+	  if ((crecp = cache_find_by_addr(NULL, &addr, now, flag, dnsset_id)))
 	    do { 
 	      strcpy(name, cache_get_name(crecp));
 	      
@@ -255,7 +256,7 @@ size_t answer_auth(struct dns_header *he
 	      else
 		continue;
 		    
-	    } while ((crecp = cache_find_by_addr(crecp, &addr, now, flag)));
+	    } while ((crecp = cache_find_by_addr(crecp, &addr, now, flag, dnsset_id)));
 
 	  if (found)
 	    nxdomain = 0;
@@ -471,7 +472,7 @@ size_t answer_auth(struct dns_header *he
 	{	  
 	  *cut = 0; /* remove domain part */
 	  
-	  if (!strchr(name, '.') && (crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6)))
+	  if (!strchr(name, '.') && (crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6, dnsset_id)))
 	    {
 	      if (crecp->flags & F_DHCP)
 		do
@@ -489,13 +490,13 @@ size_t answer_auth(struct dns_header *he
 						qtype == T_A ? "4" : "6", &crecp->addr))
 			  anscount++;
 		      }
-		  } while ((crecp = cache_find_by_name(crecp, name, now,  F_IPV4 | F_IPV6)));
+		  } while ((crecp = cache_find_by_name(crecp, name, now,  F_IPV4 | F_IPV6, dnsset_id)));
 	    }
        	  
 	  *cut = '.'; /* restore domain part */	    
 	}
       
-      if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6)))
+      if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6, dnsset_id)))
 	{
 	  if ((crecp->flags & F_HOSTS) || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN))))
 	    do
@@ -510,7 +511,7 @@ size_t answer_auth(struct dns_header *he
 					     qtype == T_A ? "4" : "6", &crecp->addr))
 		       anscount++;
 		   }
-	      } while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4 | F_IPV6)));
+	      } while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4 | F_IPV6, dnsset_id)));
 	}
       
       /* Only supply CNAME if no record for any type is known. */
--- a/src/cache.c
+++ b/src/cache.c
@@ -200,6 +200,7 @@ static void cache_free(struct crec *crec
   crecp->flags &= ~F_FORWARD;
   crecp->flags &= ~F_REVERSE;
   crecp->uid = next_uid(); /* invalidate CNAMES pointing to this. */
+  crecp->dnsset_id = 0;
 
   if (cache_tail)
     cache_tail->next = crecp;
@@ -440,7 +441,7 @@ void cache_start_insert(void)
 }
  
 struct crec *cache_insert(char *name, struct all_addr *addr, 
-			  time_t now,  unsigned long ttl, unsigned short flags)
+                         time_t now,  unsigned long ttl, unsigned short flags, unsigned short dnsset_id)
 {
   struct crec *new;
   union bigname *big_name = NULL;
@@ -564,6 +565,7 @@ struct crec *cache_insert(char *name, st
     break;
   }
   
+  new->dnsset_id = dnsset_id;
   new->flags = flags;
   if (big_name)
     {
@@ -616,7 +618,7 @@ void cache_end_insert(void)
   new_chain = NULL;
 }
 
-struct crec *cache_find_by_name(struct crec *crecp, char *name, time_t now, unsigned int prot)
+struct crec *cache_find_by_name(struct crec *crecp, char *name, time_t now, unsigned int prot, unsigned short dnsset_id)
 {
   struct crec *ans;
   int no_rr = prot & F_NO_RR;
@@ -694,6 +696,9 @@ struct crec *cache_find_by_name(struct c
       *chainp = cache_head;
     }
 
+  while(ans && ans->dnsset_id != dnsset_id)
+      ans = ans->next;
+
   if (ans && 
       (ans->flags & F_FORWARD) &&
       (ans->flags & prot) &&     
@@ -704,7 +709,7 @@ struct crec *cache_find_by_name(struct c
 }
 
 struct crec *cache_find_by_addr(struct crec *crecp, struct all_addr *addr, 
-				time_t now, unsigned int prot)
+                               time_t now, unsigned int prot, unsigned short dnsset_id)
 {
   struct crec *ans;
 #ifdef HAVE_IPV6
@@ -759,6 +764,9 @@ struct crec *cache_find_by_addr(struct c
        *chainp = cache_head;
     }
   
+  while(ans && ans->dnsset_id != dnsset_id)
+      ans = ans->next;
+
   if (ans && 
       (ans->flags & F_REVERSE) &&
       (ans->flags & prot) &&
@@ -784,6 +792,7 @@ static void add_hosts_cname(struct crec
 	crec->addr.cname.target.cache = target;
 	crec->addr.cname.uid = target->uid;
 	crec->uid = next_uid();
+	crec->dnsset_id = 0;
 	cache_hash(crec);
 	add_hosts_cname(crec); /* handle chains */
       }
@@ -792,7 +801,7 @@ static void add_hosts_cname(struct crec
 static void add_hosts_entry(struct crec *cache, struct all_addr *addr, int addrlen, 
 			    unsigned int index, struct crec **rhash, int hashsz)
 {
-  struct crec *lookup = cache_find_by_name(NULL, cache_get_name(cache), 0, cache->flags & (F_IPV4 | F_IPV6));
+  struct crec *lookup = cache_find_by_name(NULL, cache_get_name(cache), 0, cache->flags & (F_IPV4 | F_IPV6), 0);
   int i, nameexists = 0;
   unsigned int j; 
 
@@ -848,7 +857,7 @@ static void add_hosts_entry(struct crec
   else
     {
       /* incremental read, lookup in cache */
-      lookup = cache_find_by_addr(NULL, addr, 0, cache->flags & (F_IPV4 | F_IPV6));
+      lookup = cache_find_by_addr(NULL, addr, 0, cache->flags & (F_IPV4 | F_IPV6), 0);
       if (lookup && lookup->flags & F_HOSTS)
 	cache->flags &= ~F_REVERSE;
     }
@@ -983,6 +992,7 @@ int read_hostsfile(char *filename, unsig
 		  strcat(cache->name.sname, ".");
 		  strcat(cache->name.sname, domain_suffix);
 		  cache->flags = flags;
+		  cache->dnsset_id = 0;
 		  cache->ttd = daemon->local_ttl;
 		  add_hosts_entry(cache, &addr, addrlen, index, rhash, hashsz);
 		  name_count++;
@@ -991,6 +1001,7 @@ int read_hostsfile(char *filename, unsig
 		{
 		  strcpy(cache->name.sname, canon);
 		  cache->flags = flags;
+		  cache->dnsset_id = 0;
 		  cache->ttd = daemon->local_ttl;
 		  add_hosts_entry(cache, &addr, addrlen, index, rhash, hashsz);
 		  name_count++;
@@ -1067,6 +1078,7 @@ void cache_reload(void)
 	  cache->addr.cname.target.int_name = intr;
 	  cache->addr.cname.uid = SRC_INTERFACE;
 	  cache->uid = next_uid();
+	  cache->dnsset_id = 0;
 	  cache_hash(cache);
 	  add_hosts_cname(cache); /* handle chains */
 	}
@@ -1084,6 +1096,7 @@ void cache_reload(void)
 	cache->addr.ds.keytag = ds->keytag;
 	cache->addr.ds.digest = ds->digest_type;
 	cache->uid = ds->class;
+	cache->dnsset_id = 0;
 	cache_hash(cache);
       }
 #endif
@@ -1104,6 +1117,7 @@ void cache_reload(void)
 	    cache->name.namep = nl->name;
 	    cache->ttd = hr->ttl;
 	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4 | F_NAMEP | F_CONFIG;
+	    cache->dnsset_id = 0;
 	    add_hosts_entry(cache, (struct all_addr *)&hr->addr, INADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
 	  }
 #ifdef HAVE_IPV6
@@ -1113,6 +1127,7 @@ void cache_reload(void)
 	    cache->name.namep = nl->name;
 	    cache->ttd = hr->ttl;
 	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6 | F_NAMEP | F_CONFIG;
+	    cache->dnsset_id = 0;
 	    add_hosts_entry(cache, (struct all_addr *)&hr->addr6, IN6ADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
 	  }
 #endif
@@ -1146,7 +1161,7 @@ struct in_addr a_record_from_hosts(char
   struct crec *crecp = NULL;
   struct in_addr ret;
   
-  while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4)))
+  while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4, 0)))
     if (crecp->flags & F_HOSTS)
       return *(struct in_addr *)&crecp->addr;
 
@@ -1197,6 +1212,7 @@ static void add_dhcp_cname(struct crec *
 	    aliasc->name.namep = a->alias;
 	    aliasc->addr.cname.target.cache = target;
 	    aliasc->addr.cname.uid = target->uid;
+	    aliasc->dnsset_id = 0;
 	    aliasc->uid = next_uid();
 	    cache_hash(aliasc);
 	    add_dhcp_cname(aliasc, ttd);
@@ -1222,7 +1238,7 @@ void cache_add_dhcp_entry(char *host_nam
   
   inet_ntop(prot, host_address, daemon->addrbuff, ADDRSTRLEN);
   
-  while ((crec = cache_find_by_name(crec, host_name, 0, flags | F_CNAME)))
+  while ((crec = cache_find_by_name(crec, host_name, 0, flags | F_CNAME, 0)))
     {
       /* check all addresses associated with name */
       if (crec->flags & (F_HOSTS | F_CONFIG))
@@ -1260,7 +1276,7 @@ void cache_add_dhcp_entry(char *host_nam
       return;
     }	  
   
-  if ((crec = cache_find_by_addr(NULL, (struct all_addr *)host_address, 0, flags)))
+  if ((crec = cache_find_by_addr(NULL, (struct all_addr *)host_address, 0, flags, 0)))
     {
       if (crec->flags & F_NEG)
 	{
@@ -1286,6 +1302,7 @@ void cache_add_dhcp_entry(char *host_nam
       crec->addr.addr = *host_address;
       crec->name.namep = host_name;
       crec->uid = next_uid();
+      crec->dnsset_id = 0;
       cache_hash(crec);
 
       add_dhcp_cname(crec, ttd);
@@ -1442,7 +1459,7 @@ void dump_cache(time_t now)
 	      failed_queries += serv1->failed_queries;
 	    }
 	port = prettyprint_addr(&serv->addr, daemon->addrbuff);
-	my_syslog(LOG_INFO, _("server %s#%d: queries sent %u, retried or failed %u"), daemon->addrbuff, port, queries, failed_queries);
+	my_syslog(LOG_INFO, _("server %s#%d: queries sent %u, retried or failed %u [%u]"), daemon->addrbuff, port, queries, failed_queries, serv->dnsset_id);
       }
   
   if (option_bool(OPT_DEBUG) || option_bool(OPT_LOG))
@@ -1510,9 +1527,26 @@ void dump_cache(time_t now)
 	    p += sprintf(p, "%s", cache->flags & F_IMMORTAL ? "\n" : ctime(&(cache->ttd)));
 	    /* ctime includes trailing \n - eat it */
 	    *(p-1) = 0;
+	    p--;
 #endif
+	    p += sprintf(p, " [%d]", cache->dnsset_id);
+
 	    my_syslog(LOG_INFO, "%s", daemon->namebuff);
 	  }
+      {
+        struct dns_filter *filter;
+
+	for (filter = daemon->dns_filter; filter; filter = filter->next)
+	  {
+	    my_syslog(LOG_INFO,
+		      "[%d] %s %x/%x %s %s %x",
+		      filter->dnsset_id, filter->filtername,
+		      filter->connmark, filter->connmarkmask,
+		      filter->name, filter->outmode==CNM_SET?"SET":"COPY",
+		      filter->outconnmark);
+
+	}
+      }
     }
 }
 
@@ -1579,6 +1613,18 @@ char *querystr(char *desc, unsigned shor
   return buff ? buff : "";
 }
 
+void log_mark(const char *str, unsigned int mark,
+               sa_family_t family, void *src, void *dst)
+{
+  if (!option_bool(OPT_EXTRALOG))
+    return;
+
+  inet_ntop(family, src, daemon->addrbuff, ADDRSTRLEN);
+  inet_ntop(family, dst, daemon->addrbuff2, ADDRSTRLEN);
+
+  my_syslog(LOG_INFO, "%s from %s to %s => connmark 0x%x", str, daemon->addrbuff, daemon->addrbuff2, mark);
+}
+
 void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg)
 {
   char *source, *dest = daemon->addrbuff;
--- a/src/config.h
+++ b/src/config.h
@@ -180,7 +180,7 @@ RESOLVFILE
 /* #define HAVE_LIBIDN2 */
 /* #define HAVE_CONNTRACK */
 /* #define HAVE_DNSSEC */
-
+#define HAVE_DNSFILTER
 
 /* Default locations for important system files. */
 
@@ -431,6 +431,10 @@ static char *compile_opts =
 "no-"
 #endif
 "conntrack "
+#ifndef HAVE_DNSFILTER
+"no-"
+#endif
+"dns-filter"
 #ifndef HAVE_IPSET
 "no-"
 #endif
--- a/src/conntrack.c
+++ b/src/conntrack.c
@@ -70,7 +70,17 @@ int get_incoming_mark(union mysockaddr *
 	}
       nfct_destroy(ct);
     }
-
+  if (gotit)
+    {
+      void *dst;
+      if (peer_addr->sa.sa_family == AF_INET)
+        dst = &peer_addr->in.sin_addr;
+#ifdef HAVE_IPV6
+      else
+        dst = &peer_addr->in6.sin6_addr;
+#endif
+      log_mark("GET", *markp, peer_addr->sa.sa_family, &local_addr->addr, dst);
+    }
   return gotit;
 }
 
--- a/src/dhcp-common.c
+++ b/src/dhcp-common.c
@@ -393,14 +393,14 @@ void dhcp_update_configs(struct dhcp_con
 #endif
 	if (!(config->flags & conflags) &&
 	    (config->flags & CONFIG_NAME) && 
-	    (crec = cache_find_by_name(NULL, config->hostname, 0, cacheflags)) &&
+	    (crec = cache_find_by_name(NULL, config->hostname, 0, cacheflags, 0)) &&
 	    (crec->flags & F_HOSTS))
 	  {
-	    if (cache_find_by_name(crec, config->hostname, 0, cacheflags))
+	    if (cache_find_by_name(crec, config->hostname, 0, cacheflags, 0))
 	      {
 		/* use primary (first) address */
 		while (crec && !(crec->flags & F_REVERSE))
-		  crec = cache_find_by_name(crec, config->hostname, 0, cacheflags);
+		  crec = cache_find_by_name(crec, config->hostname, 0, cacheflags, 0);
 		if (!crec)
 		  continue; /* should be never */
 		inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
--- a/src/dhcp.c
+++ b/src/dhcp.c
@@ -971,7 +971,7 @@ char *host_from_dns(struct in_addr addr)
   if (daemon->port == 0)
     return NULL; /* DNS disabled. */
   
-  lookup = cache_find_by_addr(NULL, (struct all_addr *)&addr, 0, F_IPV4);
+  lookup = cache_find_by_addr(NULL, (struct all_addr *)&addr, 0, F_IPV4, 0);
 
   if (lookup && (lookup->flags & F_HOSTS))
     {
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -253,6 +253,20 @@ struct event_desc {
 #define MS_DHCP   LOG_DAEMON
 #define MS_SCRIPT LOG_MAIL
 
+struct dns_filter {
+  char *filtername;
+  int filter_id;
+  int dnsset_id;
+  unsigned short match;
+  unsigned int connmark;
+  unsigned int connmarkmask;
+  unsigned int outconnmark;
+  char *name;
+  unsigned short outmode;
+  unsigned short namelen;
+  struct dns_filter *next;
+};
+
 struct all_addr {
   union {
     struct in_addr addr4;
@@ -414,6 +428,7 @@ struct crec {
   /* used as class if DNSKEY/DS, index to source for F_HOSTS */
   unsigned int uid; 
   unsigned short flags;
+  unsigned short dnsset_id;
   union {
     char sname[SMALLDNAME];
     union bigname *bname;
@@ -459,6 +474,13 @@ struct crec {
 #define SRC_HOSTS     2
 #define SRC_AH        3
 
+/* Values for filter marks */
+#define CNM_SET       0
+#define CNM_COPY      1
+
+/* Incoming connmark match rule */
+#define CNM_MATCH_EXACT 0
+#define CNM_MATCH_ANY 1
 
 /* struct sockaddr is not large enough to hold any address,
    and specifically not big enough to hold an IPv6 address.
@@ -512,7 +534,8 @@ struct server {
   union mysockaddr addr, source_addr;
   char interface[IF_NAMESIZE+1];
   struct serverfd *sfd; 
-  char *domain; /* set if this server only handles a domain. */ 
+  char *domain; /* set if this server only handles a domain. */
+  unsigned short dnsset_id;  /* dnsset this server is part of */
   int flags, tcpfd, edns_pktsz;
   unsigned int queries, failed_queries;
 #ifdef HAVE_LOOP
@@ -635,6 +658,7 @@ struct frec {
   struct frec *blocking_query; /* Query which is blocking us. */
 #endif
   struct frec *next;
+  const struct dns_filter *filter;
 };
 
 /* flags in top of length field for DHCP-option tables */
@@ -1079,22 +1103,27 @@ extern struct daemon {
   char *addrbuff;
   char *addrbuff2; /* only allocated when OPT_EXTRALOG */
 
+  struct dns_filter *dns_filter;
 } *daemon;
 
 /* cache.c */
 void cache_init(void);
-void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg); 
+void log_mark(const char *str, unsigned int mark,
+	      sa_family_t family, void *src, void *dst);
+void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg);
 char *record_source(unsigned int index);
 char *querystr(char *desc, unsigned short type);
 struct crec *cache_find_by_addr(struct crec *crecp,
 				struct all_addr *addr, time_t now, 
-				unsigned int prot);
+				unsigned int prot, unsigned short dnsset_id);
 struct crec *cache_find_by_name(struct crec *crecp, 
-				char *name, time_t now, unsigned int prot);
+				char *name, time_t now, unsigned int prot,
+				unsigned short dnsset_id);
 void cache_end_insert(void);
 void cache_start_insert(void);
 struct crec *cache_insert(char *name, struct all_addr *addr,
-			  time_t now, unsigned long ttl, unsigned short flags);
+			  time_t now, unsigned long ttl, unsigned short flags,
+			  unsigned short dnsset_id);
 void cache_reload(void);
 void cache_add_dhcp_entry(char *host_name, int prot, struct all_addr *host_address, time_t ttd);
 struct in_addr a_record_from_hosts(char *name, time_t now);
@@ -1139,12 +1168,13 @@ size_t setup_reply(struct dns_header *he
 		   unsigned long ttl);
 int extract_addresses(struct dns_header *header, size_t qlen, char *name,
 		      time_t now, char **ipsets, int is_sign, int check_rebind,
-		      int no_cache_dnssec, int secure, int *doctored);
+		      int no_cache_dnssec, int secure, int *doctored, unsigned short dnsset_id);
 size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
 		      struct in_addr local_addr, struct in_addr local_netmask, 
-		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader);
+		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader,
+		      const struct dns_filter *filter);
 int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, 
-			     struct bogus_addr *baddr, time_t now);
+			     struct bogus_addr *baddr, time_t now, unsigned short dnsset_id);
 int check_for_ignored_address(struct dns_header *header, size_t qlen, struct bogus_addr *baddr);
 int check_for_local_domain(char *name, time_t now);
 unsigned int questions_crc(struct dns_header *header, size_t plen, char *name);
@@ -1163,7 +1193,7 @@ int private_net(struct in_addr addr, int
 #ifdef HAVE_AUTH
 size_t answer_auth(struct dns_header *header, char *limit, size_t qlen, 
 		   time_t now, union mysockaddr *peer_addr, int local_query,
-		   int do_bit, int have_pseudoheader);
+		   int do_bit, int have_pseudoheader, const struct dns_filter *filter);
 int in_zone(struct auth_zone *zone, char *name, char **cut);
 #endif
 
@@ -1264,7 +1294,8 @@ void add_update_server(int flags,
 		       union mysockaddr *addr,
 		       union mysockaddr *source_addr,
 		       const char *interface,
-		       const char *domain);
+		       const char *domain,
+		       unsigned short dnsset_id);
 void check_servers(void);
 int enumerate_interfaces(int reset);
 void create_wildcard_listeners(void);
@@ -1529,6 +1560,14 @@ time_t periodic_slaac(time_t now, struct
 void slaac_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface, struct dhcp_lease *leases);
 #endif
 
+/* filter.c */
+#ifdef HAVE_DNSFILTER
+void log_filter(struct dns_filter *filter);
+int getdnsset_id(const char *name, struct dns_filter **result);
+const struct dns_filter *getfilter(int filter_id);
+const struct dns_filter *filter_dns_request(char *domain, unsigned int mark);
+#endif
+
 /* loop.c */
 #ifdef HAVE_LOOP
 void loop_send_probes(void);
--- /dev/null
+++ b/src/filter.c
@@ -0,0 +1,77 @@
+#include "dnsmasq.h"
+
+void log_filter(struct dns_filter *filter)
+{
+  static char markmatchstr[64];
+  static char outstr[64];
+
+  if (!option_bool(OPT_LOG))
+    return;
+
+  if (filter->match == CNM_MATCH_ANY)
+    strcpy(markmatchstr, "mark==ANY");
+  else
+    sprintf(markmatchstr, "mark==0x%x/0x%x", filter->connmark, filter->connmarkmask);
+
+  if (filter->outmode == CNM_SET)
+    sprintf(outstr, "SET mark 0x%x", filter->outconnmark);
+  else
+    strcpy(outstr, "COPY srcmark");
+
+  my_syslog(LOG_INFO, "filter %d dnsset %s: MATCH domain==%s %s %s",
+                filter->filter_id, filter->filtername, filter->name, markmatchstr,
+                outstr);
+}
+
+int getdnsset_id(const char *name, struct dns_filter **result)
+{
+  struct dns_filter *filter;
+
+  for(filter = daemon->dns_filter; filter; filter = filter->next)
+    if (strcmp(filter->filtername, name) == 0)
+      {
+        if (result)
+          *result = filter;
+
+        return filter->dnsset_id;
+      }
+
+  return 0;
+}
+
+const struct dns_filter *getfilter(int filter_id)
+{
+  struct dns_filter *filter;
+
+  if (!filter_id)
+    return NULL;
+
+  for(filter = daemon->dns_filter; filter; filter = filter->next)
+    if (filter->filter_id == filter_id)
+      {
+        return filter;
+      }
+  return NULL;
+}
+
+const struct dns_filter *filter_dns_request(char *domain, unsigned int mark)
+{
+  struct dns_filter *filter;
+  unsigned short domainlen = strlen(domain);
+
+  for(filter = daemon->dns_filter; filter; filter = filter->next) {
+
+    if (filter->namelen &&
+        (filter->namelen > domainlen ||
+         !hostname_isequal(&domain[domainlen-filter->namelen],filter->name)))
+      continue;
+
+    if (filter->match == CNM_MATCH_EXACT && filter->connmark != (mark & filter->connmarkmask))
+      continue;
+
+    log_filter(filter);
+    return filter;
+  }
+
+  return 0;
+}
--- a/src/forward.c
+++ b/src/forward.c
@@ -107,7 +107,8 @@ int send_from(int fd, int nowild, char *
 }
           
 static unsigned int search_servers(time_t now, struct all_addr **addrpp, unsigned int qtype,
-				   char *qdomain, int *type, char **domain, int *norebind)
+				   char *qdomain, int *type, char **domain, int *norebind,
+				   unsigned short dnsset_id)
 			      
 {
   /* If the query ends in the domain in one of our servers, set
@@ -120,7 +121,9 @@ static unsigned int search_servers(time_
   unsigned int flags = 0;
   
   for (serv = daemon->servers; serv; serv=serv->next)
-    if (qtype == F_DNSSECOK && !(serv->flags & SERV_DO_DNSSEC))
+    if (serv->dnsset_id != dnsset_id && !(serv->flags & (SERV_NO_REBIND|SERV_NO_ADDR)))
+      continue;
+    else if (qtype == F_DNSSECOK && !(serv->flags & SERV_DO_DNSSEC))
       continue;
     /* domain matches take priority over NODOTS matches */
     else if ((serv->flags & SERV_FOR_NODOTS) && *type != SERV_HAS_DOMAIN && !strchr(qdomain, '.') && namelen != 0)
@@ -154,7 +157,10 @@ static unsigned int search_servers(time_
 	    (domainlen == 0 || namelen == domainlen || *(matchstart-1) == '.' ))
 	  {
 	    if ((serv->flags & SERV_NO_REBIND) && norebind)	
-	      *norebind = 1;
+	      {
+		*norebind = 1;
+		my_syslog(LOG_INFO, "Domain Rebind match found (domain=%s)", qdomain);
+	      }
 	    else
 	      {
 		unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6;
@@ -232,7 +238,7 @@ static unsigned int search_servers(time_
 static int forward_query(int udpfd, union mysockaddr *udpaddr,
 			 struct all_addr *dst_addr, unsigned int dst_iface,
 			 struct dns_header *header, size_t plen, time_t now, 
-			 struct frec *forward, int ad_reqd, int do_bit)
+			 struct frec *forward, int ad_reqd, int do_bit, const struct dns_filter *filter)
 {
   char *domain = NULL;
   int type = SERV_DO_DNSSEC, norebind = 0;
@@ -247,9 +253,18 @@ static int forward_query(int udpfd, unio
   void *hash = &crc;
 #endif
  unsigned int gotname = extract_request(header, plen, daemon->namebuff, NULL);
+  unsigned int filter_id = 0;
+  unsigned int dnsset_id = 0;
+
 
  (void)do_bit;
 
+  if (filter)
+    {
+      filter_id = filter->filter_id;
+      dnsset_id = filter->dnsset_id;
+    }
+
   /* may be no servers available. */
   if (forward || (hash && (forward = lookup_frec_by_sender(ntohs(header->id), udpaddr, hash))))
     {
@@ -327,7 +342,7 @@ static int forward_query(int udpfd, unio
   else 
     {
       if (gotname)
-	flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind);
+       flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind, dnsset_id);
       
 #ifdef HAVE_DNSSEC
       do_dnssec = type & SERV_DO_DNSSEC;
@@ -349,6 +364,7 @@ static int forward_query(int udpfd, unio
 	  memcpy(forward->hash, hash, HASH_SIZE);
 	  forward->forwardall = 0;
 	  forward->flags = 0;
+	  forward->filter = filter;
 	  if (norebind)
 	    forward->flags |= FREC_NOREBIND;
 	  if (header->hb4 & HB4_CD)
@@ -445,6 +461,7 @@ static int forward_query(int udpfd, unio
 	  
 	  if (type == (start->flags & SERV_TYPE) &&
 	      (type != SERV_HAS_DOMAIN || hostname_isequal(domain, start->domain)) &&
+	      (start->dnsset_id == dnsset_id) &&
 	      !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
 	    {
 	      int fd;
@@ -472,14 +489,34 @@ static int forward_query(int udpfd, unio
 		      daemon->rfd_save = forward->rfd4;
 		      fd = forward->rfd4->fd;
 		    }
-
 #ifdef HAVE_CONNTRACK
 		  /* Copy connection mark of incoming query to outgoing connection. */
 		  if (option_bool(OPT_CONNTRACK))
 		    {
 		      unsigned int mark;
 		      if (get_incoming_mark(&forward->source, &forward->dest, 0, &mark))
-			setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+			{
+			  void *src;
+			  if (forward->source.sa.sa_family == AF_INET)
+			    src = &forward->source.in.sin_addr;
+#ifdef HAVE_IPV6
+			  else
+			    src = &forward->source.in6.sin6_addr;
+#endif
+
+#if defined(HAVE_DNSFILTER)
+			  if (filter && filter->outmode == CNM_SET)
+			    {
+			      mark = (mark & ~filter->connmarkmask) | (filter->outconnmark & filter->connmarkmask);
+			      log_mark("SET", mark, forward->source.sa.sa_family, src, &forward->dest.addr);
+			    }
+			  else
+			    log_mark("COPY-ORIG", mark, forward->source.sa.sa_family, src, &forward->dest.addr);
+#else /* HAVE_DNSFILTER */
+			  log_mark("COPY-ORIG", mark, forward->source.sa.sa_family, src, &forward->dest.addr);
+#endif /* HAVE_DNSFILTER */
+			  setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+			}
 		    }
 #endif
 		}
@@ -557,17 +594,21 @@ static int forward_query(int udpfd, unio
 
 static size_t process_reply(struct dns_header *header, time_t now, struct server *server, size_t n, int check_rebind, 
 			    int no_cache, int cache_secure, int bogusanswer, int ad_reqd, int do_bit, int added_pheader, 
-			    int check_subnet, union mysockaddr *query_source)
+			    int check_subnet, union mysockaddr *query_source, const struct dns_filter *filter)
 {
   unsigned char *pheader, *sizep;
   char **sets = 0;
   int munged = 0, is_sign;
-  size_t plen; 
+  size_t plen;
+  int dnsset_id = 0;
 
   (void)ad_reqd;
   (void)do_bit;
   (void)bogusanswer;
 
+  if (filter)
+    dnsset_id = filter->dnsset_id;
+
 #ifdef HAVE_IPSET
   if (daemon->ipsets && extract_request(header, n, daemon->namebuff, NULL))
     {
@@ -654,7 +695,7 @@ static size_t process_reply(struct dns_h
     }  
 
   if (daemon->bogus_addr && RCODE(header) != NXDOMAIN &&
-      check_for_bogus_wildcard(header, n, daemon->namebuff, daemon->bogus_addr, now))
+      check_for_bogus_wildcard(header, n, daemon->namebuff, daemon->bogus_addr, now, dnsset_id))
     {
       munged = 1;
       SET_RCODE(header, NXDOMAIN);
@@ -678,7 +719,7 @@ static size_t process_reply(struct dns_h
 	  cache_secure = 0;
 	}
       
-      if (extract_addresses(header, n, daemon->namebuff, now, sets, is_sign, check_rebind, no_cache, cache_secure, &doctored))
+      if (extract_addresses(header, n, daemon->namebuff, now, sets, is_sign, check_rebind, no_cache, cache_secure, &doctored, dnsset_id))
 	{
 	  my_syslog(LOG_WARNING, _("possible DNS-rebind attack detected: %s"), daemon->namebuff);
 	  munged = 1;
@@ -815,7 +856,7 @@ void reply_query(int fd, int family, tim
 		header->hb4 |= HB4_AD;
 	      if (forward->flags & FREC_DO_QUESTION)
 		add_do_bit(header, nn,  (unsigned char *)pheader + plen);
-	      forward_query(-1, NULL, NULL, 0, header, nn, now, forward, forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION);
+	      forward_query(-1, NULL, NULL, 0, header, nn, now, forward, forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION, forward->filter);
 	      return;
 	    }
 	}
@@ -1089,7 +1130,7 @@ void reply_query(int fd, int family, tim
       
       if ((nn = process_reply(header, now, forward->sentto, (size_t)n, check_rebind, no_cache_dnssec, cache_secure, bogusanswer, 
 			      forward->flags & FREC_AD_QUESTION, forward->flags & FREC_DO_QUESTION, 
-			      forward->flags & FREC_ADDED_PHEADER, forward->flags & FREC_HAS_SUBNET, &forward->source)))
+			      forward->flags & FREC_ADDED_PHEADER, forward->flags & FREC_HAS_SUBNET, &forward->source, forward->filter)))
 	{
 	  header->id = htons(forward->orig_id);
 	  header->hb4 |= HB4_RA; /* recursion if available */
@@ -1152,6 +1193,10 @@ void receive_query(struct listener *list
 #else
   int check_dst = !option_bool(OPT_NOWILD);
 #endif
+#if defined(HAVE_CONNTRACK) || defined(HAVE_DNSFILTER)
+  unsigned int mark = 0;
+#endif
+  const struct dns_filter *filter = NULL;
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
@@ -1416,11 +1461,25 @@ void receive_query(struct listener *list
 	udp_size = PACKETSZ; /* Sanity check - can't reduce below default. RFC 6891 6.2.3 */
     }
 
+  // lookup to what filter this matches
+#ifdef HAVE_DNSFILTER
+  if (daemon->dns_filter)
+    {
+#  ifdef HAVE_CONNTRACK
+      /* Copy connection mark of incoming query to outgoing connection. */
+      if (option_bool(OPT_CONNTRACK))
+        get_incoming_mark(&source_addr, &dst_addr, 0, &mark);
+#  endif
+      filter = filter_dns_request(daemon->namebuff, mark);
+    }
+#endif
+
+
 #ifdef HAVE_AUTH
   if (auth_dns)
     {
       m = answer_auth(header, ((char *) header) + udp_size, (size_t)n, now, &source_addr, 
-		      local_auth, do_bit, have_pseudoheader);
+		      local_auth, do_bit, have_pseudoheader, filter);
       if (m >= 1)
 	{
 	  send_from(listen->fd, option_bool(OPT_NOWILD) || option_bool(OPT_CLEVERBIND),
@@ -1437,7 +1496,8 @@ void receive_query(struct listener *list
 	ad_reqd = 1;
 
       m = answer_request(header, ((char *) header) + udp_size, (size_t)n, 
-			 dst_addr_4, netmask, now, ad_reqd, do_bit, have_pseudoheader);
+			 dst_addr_4, netmask, now, ad_reqd, do_bit, have_pseudoheader,
+			 filter);
       
       if (m >= 1)
 	{
@@ -1446,7 +1506,7 @@ void receive_query(struct listener *list
 	  daemon->local_answer++;
 	}
       else if (forward_query(listen->fd, &source_addr, &dst_addr, if_index,
-			     header, (size_t)n, now, NULL, ad_reqd, do_bit))
+                             header, (size_t)n, now, NULL, ad_reqd, do_bit, filter))
 	daemon->queries_forwarded++;
       else
 	daemon->local_answer++;
@@ -1457,7 +1517,9 @@ void receive_query(struct listener *list
 /* Recurse up the key hierarchy */
 static int tcp_key_recurse(time_t now, int status, struct dns_header *header, size_t n, 
 			   int class, char *name, char *keyname, struct server *server, 
-			   int have_mark, unsigned int mark, int *keycount)
+			   int have_mark, unsigned int mark, int *keycount,
+			   const struct dns_filter *filter, union mysockaddr *local_addr,
+			   union mysockaddr *peer_addr)
 {
   int new_status;
   unsigned char *packet = NULL;
@@ -1548,7 +1610,38 @@ static int tcp_key_recurse(time_t now, i
 #ifdef HAVE_CONNTRACK
 		/* Copy connection mark of incoming query to outgoing connection. */
 		if (have_mark)
-		  setsockopt(server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+                  {
+                    void *src, *dst;
+                    if (local_addr->sa.sa_family == AF_INET)
+                      {
+                        src = &local_addr->in.sin_addr;
+                        dst = &peer_addr->in.sin_addr;
+                      }
+#ifdef HAVE_IPV6
+                    else
+                      {
+                        src = &local_addr->in6.sin6_addr;
+			dst = &peer_addr->in6.sin6_addr;
+                      }
+#endif
+
+#if defined(HAVE_DNSFILTER)
+                    if (filter && filter->outmode == CNM_SET)
+		      {
+                        mark = (mark & ~filter->connmarkmask) | (filter->outconnmark & filter->connmarkmask);
+                        log_mark("SET", mark, local_addr->sa.sa_family, src, dst);
+                        setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+                      }
+                    else
+                      {
+                        log_mark("COPY-ORIG", mark, local_addr->sa.sa_family, src, dst);
+                        setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+                      }
+                  }
+#else
+                  log_mark("COPY-ORIG", mark, local_addr->sa.sa_family, src, dst);
+                  setsockopt(server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+#endif
 #endif	
 		
 		if (!local_bind(server->tcpfd,  &server->source_addr, server->interface, 1) ||
@@ -1581,7 +1674,8 @@ static int tcp_key_recurse(time_t now, i
 	  server->flags |= SERV_GOT_TCP;
 	  
 	  m = (c1 << 8) | c2;
-	  new_status = tcp_key_recurse(now, new_status, new_header, m, class, name, keyname, server, have_mark, mark, keycount);
+	  new_status = tcp_key_recurse(now, new_status, new_header, m, class, name, keyname, server,
+	                               have_mark, mark, keycount, filter, local_addr, peer_addr);
 	  break;
 	}
       
@@ -1629,6 +1723,8 @@ unsigned char *tcp_request(int confd, ti
   unsigned char *pheader;
   unsigned int mark = 0;
   int have_mark = 0;
+  const struct dns_filter *filter = NULL;
+  int dnsset_id = 0;
 
   (void)mark;
   (void)have_mark;
@@ -1726,6 +1822,15 @@ unsigned char *tcp_request(int confd, ti
 		      (struct all_addr *)&peer_addr.in6.sin6_addr, types);
 #endif
 	  
+#ifdef HAVE_DNSFILTER
+      /* lookup to what filter this matches */
+      if (daemon->dns_filter)
+	{
+	  filter = filter_dns_request(daemon->namebuff, mark);
+	  dnsset_id = filter ? filter->dnsset_id : 0;
+	}
+#endif
+
 #ifdef HAVE_AUTH
 	  /* find queries for zones we're authoritative for, and answer them directly */
 	  if (!auth_dns && !option_bool(OPT_LOCALISE))
@@ -1761,7 +1866,7 @@ unsigned char *tcp_request(int confd, ti
 #ifdef HAVE_AUTH
       if (auth_dns)
 	m = answer_auth(header, ((char *) header) + 65536, (size_t)size, now, &peer_addr, 
-			local_auth, do_bit, have_pseudoheader);
+			local_auth, do_bit, have_pseudoheader, filter);
       else
 #endif
 	{
@@ -1772,7 +1877,8 @@ unsigned char *tcp_request(int confd, ti
 	   
 	   /* m > 0 if answered from cache */
 	   m = answer_request(header, ((char *) header) + 65536, (size_t)size, 
-			      dst_addr_4, netmask, now, ad_reqd, do_bit, have_pseudoheader);
+			      dst_addr_4, netmask, now, ad_reqd, do_bit, have_pseudoheader,
+			      filter);
 	  
 	  /* Do this by steam now we're not in the select() loop */
 	  check_log_writer(1); 
@@ -1792,7 +1898,7 @@ unsigned char *tcp_request(int confd, ti
 		}
 	      
 	      if (gotname)
-		flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind);
+		flags = search_servers(now, &addrp, gotname, daemon->namebuff, &type, &domain, &norebind, dnsset_id);
 	      
 	      type &= ~SERV_DO_DNSSEC;
 	      
@@ -1832,6 +1938,7 @@ unsigned char *tcp_request(int confd, ti
 		      /* server for wrong domain */
 		      if (type != (last_server->flags & SERV_TYPE) ||
 			  (type == SERV_HAS_DOMAIN && !hostname_isequal(domain, last_server->domain)) ||
+			  (last_server->dnsset_id != dnsset_id) ||
 			  (last_server->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
 			continue;
 
@@ -1844,7 +1951,37 @@ unsigned char *tcp_request(int confd, ti
 #ifdef HAVE_CONNTRACK
 			  /* Copy connection mark of incoming query to outgoing connection. */
 			  if (have_mark)
-			    setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+			    {
+			      void *src, *dst;
+			      if (local_addr->sa.sa_family == AF_INET)
+				{
+				  src = &local_addr->in.sin_addr;
+				  dst = &peer_addr.in.sin_addr;
+				}
+#ifdef HAVE_IPV6
+			      else
+				{
+				 src = &local_addr->in6.sin6_addr;
+				 dst = &peer_addr.in6.sin6_addr;
+				}
+#endif
+#if defined(HAVE_DNSFILTER)
+			      if (filter && filter->outmode == CNM_SET)
+				{
+				  mark = (mark & ~filter->connmarkmask) | (filter->outconnmark & filter->connmarkmask);
+				  log_mark("SET", mark, local_addr->sa.sa_family, src, dst);
+				  setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+				}
+			      else
+				{
+				  log_mark("COPY-ORIG", mark, local_addr->sa.sa_family, src, dst);
+				  setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+				}
+#else /* HAVE_DNSFILTER */
+				log_mark("COPY-ORIG", mark, local_addr->sa.sa_family, src, dst);
+				setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
+#endif /* HAVE_DNSFILTER */
+			    }
 #endif	
 		      
 			  if ((!local_bind(last_server->tcpfd,  &last_server->source_addr, last_server->interface, 1) ||
@@ -1916,7 +2053,8 @@ unsigned char *tcp_request(int confd, ti
 			{
 			  int keycount = DNSSEC_WORK; /* Limit to number of DNSSEC questions, to catch loops and avoid filling cache. */
 			  int status = tcp_key_recurse(now, STAT_OK, header, m, 0, daemon->namebuff, daemon->keyname, 
-						       last_server, have_mark, mark, &keycount);
+						       last_server, have_mark, mark, &keycount, filter);
+
 			  char *result, *domain = "result";
 			  
 			  if (status == STAT_ABANDONED)
@@ -1972,7 +2110,7 @@ unsigned char *tcp_request(int confd, ti
 
 		      m = process_reply(header, now, last_server, (unsigned int)m, 
 					option_bool(OPT_NO_REBIND) && !norebind, no_cache_dnssec, cache_secure, bogusanswer,
-					ad_reqd, do_bit, added_pheader, check_subnet, &peer_addr); 
+					ad_reqd, do_bit, added_pheader, check_subnet, &peer_addr, filter);
 		      
 		      break;
 		    }
--- a/src/network.c
+++ b/src/network.c
@@ -1370,7 +1370,8 @@ void add_update_server(int flags,
 		       union mysockaddr *addr,
 		       union mysockaddr *source_addr,
 		       const char *interface,
-		       const char *domain)
+		       const char *domain,
+		       unsigned short dnsset_id)
 {
   struct server *serv, *next = NULL;
   char *domain_str = NULL;
@@ -1429,6 +1430,7 @@ void add_update_server(int flags,
       serv->domain = domain_str;
       serv->next = next;
       serv->queries = serv->failed_queries = 0;
+      serv->dnsset_id = dnsset_id;
 #ifdef HAVE_LOOP
       serv->uid = rand32();
 #endif      
@@ -1617,6 +1619,7 @@ int reload_servers(char *fname)
     
   while ((line = fgets(daemon->namebuff, MAXDNAME, f)))
     {
+      int dnsset_id = 0;
       union mysockaddr addr, source_addr;
       char *token = strtok(line, " \t\n\r");
       
@@ -1673,7 +1676,18 @@ int reload_servers(char *fname)
 	continue;
 #endif 
 
-      add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
+      /* check for comment line that has 'dnsset:' in it, token
+         will point to the set name */
+      if (daemon->dns_filter &&
+          (token = strtok(NULL, "\t\n\r")) &&
+          token[0] == '#' &&
+          (token = strstr(token, "dnsset:")) != NULL &&
+          (token = strtok(&token[7], " \t\n\r")) != NULL) {
+              dnsset_id = getdnsset_id(token, NULL);
+      }
+
+      add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL, dnsset_id);
+
       gotone = 1;
     }
   
--- a/src/option.c
+++ b/src/option.c
@@ -160,7 +160,8 @@ struct myoption {
 #define LOPT_DHCPTTL       348
 #define LOPT_TFTP_MTU      349
 #define LOPT_REPLY_DELAY   350
- 
+#define LOPT_DNSFILTER     351
+
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
 #else
@@ -317,6 +318,7 @@ static const struct myoption opts[] =
     { "dhcp-prefix-class", 1, 0, LOPT_PREF_CLSS },
 #endif
     { "dhcp-relay", 1, 0, LOPT_RELAY },
+    { "dns-filter", 1, 0, LOPT_DNSFILTER },
     { "ra-param", 1, 0, LOPT_RA_PARAM },
     { "quiet-dhcp", 0, 0, LOPT_QUIET_DHCP },
     { "quiet-dhcp6", 0, 0, LOPT_QUIET_DHCP6 },
@@ -489,6 +491,7 @@ static struct {
   { LOPT_PREF_CLSS, ARG_DUP, "set:tag,<class>", gettext_noop("Specify DHCPv6 prefix class"), NULL },
 #endif
   { LOPT_RA_PARAM, ARG_DUP, "<iface>,[mtu:<value>|<interface>|off,][<prio>,]<intval>[,<lifetime>]", gettext_noop("Set MTU, priority, resend-interval and router-lifetime"), NULL },
+  { LOPT_DNSFILTER, ARG_DUP, "<filtername>,<domainname>,<mark>[/<markmask>]", gettext_noop("Define a DNS filter"), NULL },
   { LOPT_QUIET_DHCP, OPT_QUIET_DHCP, NULL, gettext_noop("Do not log routine DHCP."), NULL },
   { LOPT_QUIET_DHCP6, OPT_QUIET_DHCP6, NULL, gettext_noop("Do not log routine DHCPv6."), NULL },
   { LOPT_QUIET_RA, OPT_QUIET_RA, NULL, gettext_noop("Do not log RA."), NULL },
@@ -1803,6 +1806,130 @@ static int one_opt(int option, char *arg
 	break;
       }
       
+    case LOPT_DNSFILTER:  /* --dns-filter */
+# if !defined(HAVE_DNSFILTER)
+      ret_err(_("recompile with HAVE_DNSFILTER defined to enable DNS filters"));
+# else
+      {
+        unsigned int mark = 0;
+        unsigned int markmask = 0xffffffff;
+        unsigned int outmark = 0;
+        unsigned short outmode = CNM_COPY;
+        unsigned short match = CNM_MATCH_EXACT;
+
+        char *filtername, *domainname = NULL;
+        static int max_filter_dnsset_id = 0, max_filter_id = 0;
+
+        struct dns_filter *new, *filter = NULL;
+
+        char *domain, *markstr, *outmarkstr;
+        char *markmaskstr, *endptr;
+
+        /* dns-filter=data_set,google.com,0x0/0xffffffff,0xff/0x0 */
+        filtername = arg;
+        if (!(domain = split(arg)))
+          ret_err(_("bad dns filter"));
+
+        if (!(markstr = split(domain)))
+          ret_err(_("bad dns filter"));
+
+        if (!(outmarkstr = split(markstr)))
+          ret_err(_("bad dns filter"));
+
+        domainname = canonicalise_opt(domain);
+
+        if (!(markmaskstr = split_chr(markstr, '/')))
+          ret_err(_("bad dns filter"));
+
+        errno = 0;
+        markmask = strtoul(markmaskstr, &endptr, 0);
+        if (errno || *endptr != '\0')
+          ret_err(_("bad mark mask"));
+
+        if (!strcmp(markstr, "any"))
+          {
+            match = CNM_MATCH_ANY;
+            mark = 0;
+          }
+        else
+          {
+            match = CNM_MATCH_EXACT;
+            errno = 0;
+            mark = strtoul(markstr, &endptr, 0);
+            if (errno || *endptr != '\0')
+              ret_err(_("bad mark"));
+
+            if ((mark & ~markmask) != 0)
+              ret_err(_("inconsistent mark/markmask values"));
+          }
+
+        if (!strcmp(outmarkstr, "copy"))
+          outmode = CNM_COPY;
+        else if (!strcmp(outmarkstr, "default"))
+          {
+            outmode = CNM_SET;
+            outmark = 0;
+          }
+        else
+          {
+            errno = 0;
+            outmark = strtoul(outmarkstr, &endptr, 0);
+            if (errno || *endptr != '\0')
+                  ret_err(_("bad mark"));
+            outmode = CNM_SET;
+          }
+        getdnsset_id(filtername, &filter);
+        new = opt_malloc(sizeof(struct dns_filter));
+        new->next = NULL;
+        new->filter_id = ++max_filter_id;
+        if (daemon->dns_filter)
+          {
+            struct dns_filter *last = daemon->dns_filter;
+            while(last->next)
+              last = last->next;
+            last->next = new;
+          }
+        else
+          {
+            daemon->dns_filter = new;
+          }
+
+        if (filter)
+	  {
+            new->filtername = filter->filtername;
+            new->dnsset_id = filter->dnsset_id;
+          }
+	else
+	  {
+	    new->filtername = strdup(filtername);
+	    if (!new->filtername)
+	      die(_("could not get memory"), NULL, EC_NOMEM);
+
+	    if (!strcmp(filtername, "default"))
+	      new->dnsset_id = 0;
+	    else
+	      new->dnsset_id = ++max_filter_dnsset_id;
+          }
+        if (domainname)
+          {
+            new->name = domainname;
+            new->namelen = strlen(domainname);
+          }
+        else
+          {
+            new->name = NULL;
+            new->namelen = 0;
+          }
+        new->match = match;
+        new->connmark = mark;
+        new->connmarkmask = markmask;
+        new->outconnmark = outmark;
+        new->outmode = outmode;
+        log_filter(new);
+      }
+# endif
+      break;
+
     case 't': /*  --mx-target */
       if (!(daemon->mxtarget = canonicalise_opt(arg)))
 	ret_err(_("bad MX target"));
--- a/src/rfc1035.c
+++ b/src/rfc1035.c
@@ -584,7 +584,7 @@ static int find_soa(struct dns_header *h
    expired and cleaned out that way. 
    Return 1 if we reject an address because it look like part of dns-rebinding attack. */
 int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t now, 
-		      char **ipsets, int is_sign, int check_rebind, int no_cache_dnssec, int secure, int *doctored)
+                      char **ipsets, int is_sign, int check_rebind, int no_cache_dnssec, int secure, int *doctored, unsigned short dnsset_id)
 {
   unsigned char *p, *p1, *endrr, *namep;
   int i, j, qtype, qclass, aqtype, aqclass, ardlen, res, searched_soa = 0;
@@ -680,7 +680,7 @@ int extract_addresses(struct dns_header
 			  goto cname_loop;
 			}
 		      
-		      cache_insert(name, &addr, now, cttl, name_encoding | secflag | F_REVERSE);
+		      cache_insert(name, &addr, now, cttl, name_encoding | secflag | F_REVERSE, dnsset_id);
 		      found = 1; 
 		    }
 		  
@@ -698,7 +698,7 @@ int extract_addresses(struct dns_header
 		  ttl = find_soa(header, qlen, NULL, doctored);
 		}
 	      if (ttl)
-		cache_insert(NULL, &addr, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | secflag);	
+		cache_insert(NULL, &addr, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | secflag, dnsset_id);
 	    }
 	}
       else
@@ -748,7 +748,7 @@ int extract_addresses(struct dns_header
 		    {
 		      if (!cname_count--)
 			return 0; /* looped CNAMES */
-		      newc = cache_insert(name, NULL, now, attl, F_CNAME | F_FORWARD | secflag);
+		      newc = cache_insert(name, NULL, now, attl, F_CNAME | F_FORWARD | secflag, dnsset_id);
 		      if (newc)
 			{
 			  newc->addr.cname.target.cache = NULL;
@@ -809,7 +809,7 @@ int extract_addresses(struct dns_header
 			}
 #endif
 		      
-		      newc = cache_insert(name, &addr, now, attl, flags | F_FORWARD | secflag);
+		      newc = cache_insert(name, &addr, now, attl, flags | F_FORWARD | secflag, dnsset_id);
 		      if (newc && cpp)
 			{
 			  cpp->addr.cname.target.cache = newc;
@@ -835,7 +835,7 @@ int extract_addresses(struct dns_header
 		 pointing at this, inherit its TTL */
 	      if (ttl || cpp)
 		{
-		  newc = cache_insert(name, NULL, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | secflag);	
+		  newc = cache_insert(name, NULL, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | secflag, dnsset_id);
 		  if (newc && cpp)
 		    {
 		      cpp->addr.cname.target.cache = newc;
@@ -950,7 +950,7 @@ int check_for_local_domain(char *name, t
   /* Note: the call to cache_find_by_name is intended to find any record which matches
      ie A, AAAA, CNAME. */
 
-  if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6 | F_CNAME |F_NO_RR)) &&
+  if ((crecp = cache_find_by_name(NULL, name, now, F_IPV4 | F_IPV6 | F_CNAME |F_NO_RR, 0)) &&
       (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)))
     return 1;
   
@@ -981,7 +981,7 @@ int check_for_local_domain(char *name, t
    If so mung is into an NXDOMAIN reply and also put that information
    in the cache. */
 int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, 
-			     struct bogus_addr *baddr, time_t now)
+                            struct bogus_addr *baddr, time_t now, unsigned short dnsset_id)
 {
   unsigned char *p;
   int i, qtype, qclass, rdlen;
@@ -1013,7 +1013,7 @@ int check_for_bogus_wildcard(struct dns_
 		/* Found a bogus address. Insert that info here, since there no SOA record
 		   to get the ttl from in the normal processing */
 		cache_start_insert();
-		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);
+		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN, dnsset_id);
 		cache_end_insert();
 		
 		return 1;
@@ -1245,7 +1245,8 @@ static unsigned long crec_ttl(struct cre
 /* return zero if we can't answer from cache, or packet size if we can */
 size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
 		      struct in_addr local_addr, struct in_addr local_netmask, 
-		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader) 
+		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader,
+		      const struct dns_filter *filter)
 {
   char *name = daemon->namebuff;
   unsigned char *p, *ansp;
@@ -1259,6 +1260,7 @@ size_t answer_request(struct dns_header
   int nxdomain = 0, auth = 1, trunc = 0, sec_data = 1;
   struct mx_srv_record *rec;
   size_t len;
+  int dnsset_id = filter ? filter->dnsset_id : 0;
 
   if (ntohs(header->ancount) != 0 ||
       ntohs(header->nscount) != 0 ||
@@ -1425,7 +1427,7 @@ size_t answer_request(struct dns_header
 			 
 		    }
 		}
-	      else if ((crecp = cache_find_by_addr(NULL, &addr, now, is_arpa)))
+	      else if ((crecp = cache_find_by_addr(NULL, &addr, now, is_arpa, dnsset_id)))
 		{
 		  /* Don't use cache when DNSSEC data required, unless we know that
 		     the zone is unsigned, which implies that we're doing
@@ -1468,7 +1470,7 @@ size_t answer_request(struct dns_header
 				    anscount++;
 				}
 			    }
-			} while ((crecp = cache_find_by_addr(crecp, &addr, now, is_arpa)));
+			} while ((crecp = cache_find_by_addr(crecp, &addr, now, is_arpa, dnsset_id)));
 		    }
 		}
 	      else if (is_rev_synth(is_arpa, &addr, name))
@@ -1645,7 +1647,7 @@ size_t answer_request(struct dns_header
 		}
 
 	    cname_restart:
-	      if ((crecp = cache_find_by_name(NULL, name, now, flag | F_CNAME | (dryrun ? F_NO_RR : 0))))
+	      if ((crecp = cache_find_by_name(NULL, name, now, flag | F_CNAME | (dryrun ? F_NO_RR : 0), dnsset_id)))
 		{
 		  int localise = 0;
 		  
@@ -1661,7 +1663,7 @@ size_t answer_request(struct dns_header
 			    localise = 1;
 			    break;
 			  } 
-			} while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME)));
+			} while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME, dnsset_id)));
 		      crecp = save;
 		    }
 
@@ -1731,7 +1733,7 @@ size_t answer_request(struct dns_header
 				  anscount++;
 			      }
 			  }
-		      } while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME)));
+		      } while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME, dnsset_id)));
 		}
 	      else if (is_name_synthetic(flag, name, &addr))
 		{
@@ -1748,7 +1750,7 @@ size_t answer_request(struct dns_header
 
 	  if (qtype == T_CNAME || qtype == T_ANY)
 	    {
-	      if ((crecp = cache_find_by_name(NULL, name, now, F_CNAME)) &&
+	      if ((crecp = cache_find_by_name(NULL, name, now, F_CNAME, dnsset_id)) &&
 		  (qtype == T_CNAME || (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG  | (dryrun ? F_NO_RR : 0)))))
 		{
 		  if (!(crecp->flags & F_DNSSECOK))
@@ -1788,7 +1790,7 @@ size_t answer_request(struct dns_header
 		  }
 	      
 	      if (!found && (option_bool(OPT_SELFMX) || option_bool(OPT_LOCALMX)) && 
-		  cache_find_by_name(NULL, name, now, F_HOSTS | F_DHCP | F_NO_RR))
+		  cache_find_by_name(NULL, name, now, F_HOSTS | F_DHCP | F_NO_RR, dnsset_id))
 		{ 
 		  ans = 1;
 		  if (!dryrun)
@@ -1902,7 +1904,7 @@ size_t answer_request(struct dns_header
 	    tmp->offset = 0;
 	
 	crecp = NULL;
-	while ((crecp = cache_find_by_name(crecp, rec->target, now, F_IPV4 | F_IPV6)))
+	while ((crecp = cache_find_by_name(crecp, rec->target, now, F_IPV4 | F_IPV6, dnsset_id)))
 	  {
 #ifdef HAVE_IPV6
 	    int type =  crecp->flags & F_IPV4 ? T_A : T_AAAA;
